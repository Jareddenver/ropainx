

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ropainx Admin</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;600;700&family=Lato:wght@300;400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="index.css">


</head>
<body>
    <div class="app-wrapper">
      <aside class="sidebar">
    <div id="logob">
        <img src="./icon48.png" alt="">
        <h1>Ropainx admin</h1>
    </div>

    <nav class="sidebar-nav">
        <p>Endless content</p>

        <a href="#" class="nav-item active" data-tab="twitter">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
            </svg>
            Twitter
        </a>

        <a href="#" class="nav-item" data-tab="linkedin">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                <path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/>
            </svg>
            LinkedIn <span class="coming-soon">Coming soon</span>
        </a>

        <a href="#" class="nav-item" data-tab="reddit">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                <path d="M22 12c0-5.523-4.477-10-10-10S2 6.477 2 12s4.477 10 10 10 10-4.477 10-10zM9.5 13a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zm5 0a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zm-5.5 3.5c1.333 1 3.667 1 5 0" />
            </svg>
            Reddit
        </a>

        <a href="#" class="nav-item" data-tab="swipefiles">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                <path d="M3 4a2 2 0 0 1 2-2h6l2 2h6a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4z"/>
            </svg>
            Swipe Files
        </a>

        <a href="#" class="nav-item" data-tab="emails">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                <path d="M4 4h16a2 2 0 0 1 2 2v0l-10 6L2 6v0a2 2 0 0 1 2-2zm0 4.236 8 4.764 8-4.764V18a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V8.236z"/>
            </svg>
            Emails
        </a>

        <p>Understand people</p>

        <a href="#" class="nav-item" data-tab="complaints">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
            </svg>
            Complaints
        </a>
    </nav>

    <div class="user-profile" id="userProfile">
        <p>Welcome on Ropainx</p>
        <div class="pro-log">
            <div class="profile-section">
                <img src="https://via.placeholder.com/40" alt="Profile" id="userPhoto">
               <div class="profile-info">
                    <div class="username" id="userName">User</div>
                    <div class="handle" id="userHandle">@username</div>
                </div>
                <button id="moreBtn" class="more-btn">‚ãØ</button>
                <div id="dropdownMenu" class="dropdown-menu z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg" dir="ltr" tabindex="-1">
                    <!--<div class="px-3 py-2 font-semibold text-sm">
                        <span id="dropdownUserName">User</span>
                        <span class="block font-normal text-xs opacity-70" id="dropdownUserHandle">@username</span>
                    </div>-->
                    <!--<div role="separator" class="-mx-1 my-1 h-px bg-border"></div>-->
                    <a id="dropdownPayment" href="/payment.html" class="relative flex items-center rounded-sm px-3 py-2 text-sm hover:bg-accent">
                        üí≥ Payment
                    </a>
                    <div id="dropdownLogout" class="relative flex items-center rounded-sm px-3 py-2 text-sm hover:bg-accent cursor-pointer">
                        üö™ Logout
                    </div>
                </div>
            </div>
        </div>
    </div>
</aside>

        <main class="main-content">
            <div class="container">
            <!-- Ajouter au d√©but de .container dans main-content -->


<!-- Contenus par tab -->
<div id="twitter" class="tab-content active">
<div class="page-header">
    <div class="header-content">
    <svg width="32" height="32" viewBox="0 0 24 24" fill="black" class="twitter-logo">
                <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
            </svg>
        <div class="header-title">

            <h3>Endless Tweets</h3>
             <p class="header-description">Generate unlimited engaging tweets  with <span class="textt">no friction and out of your own preferences</span> </p>
        </div>

    </div>

</div>
    <!-- Ici ton contenu Twitter existant : filter-selector, input-container, refresh-btn, tweets-container, etc. -->
    <!-- D√©place tout le contenu actuel de .container ici (sauf page-header d√©j√† au-dessus) -->
    <div class="style-progress">
    <div class="style-progress-bar" id="styleProgressBar"></div>
    <div class="style-progress-text" id="styleProgressText">0/10,000</div>
</div>
                <div class="filter-selector" id="filterSelector">
                    <div class="filter-tag" data-filter="tweet-viral">
                        Constructive Critique
                    </div>
                    <div class="filter-tag" data-filter="thread-twitter">
                        Twitter Thread
                    </div>
                    <div class="filter-tag" data-filter="reformulation-simple">
                        Simple Reformulation
                    </div>
                    <div class="filter-tag" data-filter="angle-contrarian">
                        Contrarian Angle
                    </div>
                    <div class="filter-tag" data-filter="storytelling">
                        Storytelling
                    </div>
                    <div class="filter-tag" data-filter="question-provocante">
                        Provocative Question
                    </div>
                    <div class="filter-tag" data-filter="metaphore-creative">
                        Creative Metaphor
                    </div>
                    <div class="filter-tag" data-filter="style-personnel">
                        Personal Style
                    </div>
                    <div class="clear-filter" id="clearFilter">‚úï Clear</div>
                </div>
                <div class="input-container">


                    <div class="circle-btn loading-pulse" id="customInputBtn">
                        <span class="icon"></span>
                        <div class="input-wrapper">
                            <input type="text" class="custom-input" id="customInput" placeholder="Enter #feedback or your style...">
                        </div>
                    </div>
                </div>
                <button class="refresh-btn" id="refreshBtn">Refresh</button>
                <div id="tweets-container">
                    <div class="no-tweets">
                        Write a comment on Twitter/X with the extension enabled to see generated tweets here.
                    </div>
                </div>
                <div class="schedule-dialog" id="schedule-dialog">
                    <h3>Schedule the tweet</h3>
                    <div class="datetime-group">
                        <label for="scheduleDate">üìÖ Date</label>
                        <input type="date" id="scheduleDate" class="datetime-input">
                    </div>
                    <div class="datetime-group">
                        <label for="scheduleTime">‚è∞ Time</label>
                        <input type="time" id="scheduleTime" class="datetime-input">
                    </div>
                    <div class="button-group">
                        <button class="cancel" onclick="closeScheduleDialog()">Cancel</button>
                        <button onclick="confirmSchedule()">Schedule</button>
                    </div>
                </div>
</div>
<div id="linkedin" class="tab-content">
    <div class="page-header"> <!-- M√™me header -->
        <div class="header-content">
            <svg width="32" height="32" viewBox="0 0 24 24" fill="black" class="twitter-logo"> <!-- Change ic√¥ne si besoin -->
                <path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/>
            </svg>
            <div class="header-title">
                <h3>Endless LinkedIn Posts</h3>
                <p class="header-description">Generate unlimited engaging posts with <span class="textt">no friction and out of your own preferences</span></p>
            </div>
        </div>
    </div>
    <div class="no-tweets">Coming soon for LinkedIn...</div> <!-- Placeholder -->
</div>
<div id="facebook" class="tab-content">
    <div class="page-header"> <!-- M√™me header -->
        <div class="header-content">
            <svg width="32" height="32" viewBox="0 0 24 24" fill="black" class="facebook-logo"> <!-- Change ic√¥ne si besoin -->
                <path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/>
            </svg>
            <div class="header-title">
                <h3>Endless Facebook Posts</h3>
                <p class="header-description">Generate unlimited engaging posts with <span class="textt">no friction and out of your own preferences</span></p>
            </div>
        </div>
    </div>
    <div class="no-tweets">Coming soon for facebook...</div> <!-- Placeholder -->
</div>
<div id="reddit" class="tab-content">
    <!-- M√™me header, change titre/desc/ic√¥ne -->
    <div class="page-header">
        <div class="header-content">
            <svg width="32" height="32" viewBox="0 0 24 24" fill="black" class="twitter-logo">
                <path d="M22 12c0-5.523-4.477-10-10-10S2 6.477 2 12s4.477 10 10 10 10-4.477 10-10zM9.5 13a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zm5 0a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zm-5.5 3.5c1.333 1 3.667 1 5 0" />
            </svg>
            <div class="header-title">
                <h3>Endless Reddit Posts</h3>
                <p class="header-description">Generate unlimited engaging posts with <span class="textt">no friction and out of your own preferences</span></p>
            </div>
        </div>
    </div>
    <div class="no-tweets">Coming soon for Reddit...</div>
</div>
<!-- Ajoute pareil pour swipefiles, emails, complaints ‚Äì change data-tab en id, et ic√¥ne/titre/desc -->
<div id="swipefiles" class="tab-content">
    <!-- ... m√™me structure ... -->
    <div class="no-tweets">Swipe Files content here (coming soon).</div>
</div>
<div id="emails" class="tab-content">
    <!-- ... -->
    <div class="no-tweets">Emails content here (coming soon).</div>
</div>
<div id="emails" class="tab-content">
    <!-- ... -->
    <div class="no-tweets">Emails content here (coming soon).</div>
</div>
<div id="complaints" class="tab-content">
    <!-- ... -->
    <div class="no-tweets">Complaints content here (coming soon).</div>
</div>

                <div class="notification" id="notification">
                    <div id="notificationMessage"></div>
                </div>
<div id="onboarding-popup" class="popup">
    <h2>Welcome! Tell us about your profile</h2>
    <form id="onboarding-form">
        <div class="question-step active" data-step="1">
            <label>1. What's your full name?</label>
            <input type="text" name="name" required>
        </div>
        <div class="question-step" data-step="2">
            <label>2. What's your main niche or industry?</label>
            <input type="text" name="niche" required>
        </div>
        <div class="question-step" data-step="3">
            <label>3. What writing tone do you prefer (e.g., professional, casual, humorous)?</label>
            <input type="text" name="tone" required>
        </div>
        <div class="question-step" data-step="4">
            <label>4. What are your favorite topics to tweet about?</label>
            <input type="text" name="topics" required>
        </div>
        <div class="question-step" data-step="5">
            <label>5. Any specific style preferences (e.g., short threads, questions, metaphors)?</label>
            <input type="text" name="style" required>
        </div>
        <div class="popup-buttons">
            <button type="button" id="skip-onboarding">Skip now</button>
            <button type="button" id="next-step">Next</button>
            <button type="submit" id="submit-onboarding" style="display: none;">Submit</button>
        </div>
    </form>
</div>
<!--<div class="coming-soon-footer">Coming soon...</div>-->
    </div>
</main>
</div>
    <!-- Firebase SDK -->
  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
    import { getAuth, signOut, onAuthStateChanged, signInWithPopup, TwitterAuthProvider } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
    import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

    const firebaseConfig = {
        apiKey: "AIzaSyCh0EeCbrm-LzHYOJAYTuQlJJzTFBs-xjo",
        authDomain: "ropainx-b13da.firebaseapp.com",
        projectId: "ropainx-b13da",
        storageBucket: "ropainx-b13da.firebasestorage.app",
        messagingSenderId: "293729340264",
        appId: "1:293729340264:web:89bbcdc6197a05520b64dd",
        measurementId: "G-H3T6EF9E4H"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    window.auth = auth;
    window.db = db;

    const twitterProvider = new TwitterAuthProvider();

    // Update user profile
onAuthStateChanged(auth, async (user) => {
   if (user) {
        // V√©rification UID admin
        const ADMIN_UID = '5DOofrwItGflRGtUtbebf21sR2D3';
        if (user.uid !== ADMIN_UID) {
            console.log('‚ùå Acc√®s refus√©: UID non admin');
            document.querySelector('.app-wrapper').innerHTML = '<div class="no-access">Acc√®s refus√©. Ce n\'est pas votre compte admin.</div>';
            document.querySelector('.app-wrapper').style.display = 'flex';
            document.querySelector('.app-wrapper').style.justifyContent = 'center';
            document.querySelector('.app-wrapper').style.alignItems = 'center';
            document.querySelector('.app-wrapper').style.height = '100vh';
            return; // Arr√™te l'ex√©cution, page non affich√©e
        }
        try {
            const docRef = doc(db, "users", user.uid);
            const docSnap = await getDoc(docRef);

            let data = {};
            if (docSnap.exists()) {
                data = docSnap.data();
                console.log("üì¶ Firestore data:", data);
            } else {
                console.warn("‚ö†Ô∏è Aucun doc Firestore ‚Üí on prend les infos de Firebase Auth");
            }

            // Update user profile UI
            document.getElementById('userName').textContent = data.displayName || user.displayName || 'User';
            document.getElementById('userHandle').textContent = `@${data.twitterHandle || user.uid || 'user'}`;
            document.getElementById('userPhoto').src = data.photoURL || user.photoURL || 'https://via.placeholder.com/40';
            document.getElementById('dropdownUserName').textContent = data.displayName || user.displayName || 'User';
            document.getElementById('dropdownUserHandle').textContent = `@${data.twitterHandle || user.uid || 'user'}`;

document.getElementById('onboarding-form').addEventListener('submit', async (e) => {
    e.preventDefault();
    const formData = new FormData(e.target);
    const userData = {
        displayName: formData.get('name'),
        niche: formData.get('niche'),
        tone: formData.get('tone'),
        topics: formData.get('topics'),
        style: formData.get('style'),
        onboardingCompleted: true
    };

    try {
        await setDoc(doc(db, "users", auth.currentUser.uid), userData, { merge: true });
        document.getElementById('onboarding-popup').style.display = 'none';
        showNotification('Profile updated successfully!', 'success');
        fetchUserStats(); // Refresh stats after onboarding
    } catch (error) {
        console.error('Onboarding save error:', error);
        showNotification('Error saving profile.', 'error');
    }
});
            // Check if onboarding is completed
            if (!data.onboardingCompleted) {
                document.getElementById('onboarding-popup').style.display = 'block';
            }

            // Fetch and update progress bar
            await fetchUserStats();
        } catch (err) {
            console.error("‚ùå Erreur r√©cup√©ration Firestore:", err);
        }
    } else {
        console.log("‚ùå Aucun utilisateur connect√©");
        window.location.href = '/auth.html';
    }
});

</script>

<!-- DOMPurify for secure HTML display -->
<script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@emailjs/browser@3.11.0/dist/email.min.js"></script>
<script>
    emailjs.init('xCP3VGGrqcLeoxGXX');

    let isLoading = false;
    let lastUpdateTime = 0;
    let selectedFilter = null;
    let isEditing = false;
    let lastRefreshAttempt = 0;
    const MIN_REFRESH_INTERVAL = 10000;
    let tweetsDataCache = [];
    let lastETag = null;
    let styleProgress = 0;
    let scheduledTweets = [];
    let selectedMedia = new Map();
    let tweetSchedules = new Map();
    let currentTweetId = null;
    let currentTweetIndex = null;
    const isLocal = window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1";

    // D√©finir l'URL cible en fonction
    const BASE_URL = isLocal
        ? "http://localhost:3000"   // ton serveur local (adapt√© au port que tu utilises)
        : "https://ropainx.onrender.com"; // ton serveur Render
function checkAuth() {
    const idToken = localStorage.getItem('idToken');
    const uid = localStorage.getItem('uid');
    const ADMIN_UID = '5DOofrwItGflRGtUtbebf21sR2D3'; // Hardcode admin UID
    if (!idToken || !uid || uid !== ADMIN_UID) {
        console.log('‚ùå [DEBUG] Auth check failed:', { idToken: !!idToken, uid, isAdmin: uid === ADMIN_UID });
        window.location.href = '/auth.html';
        return false;
    }
    return true;
}

    async function refreshIdToken() {
        try {
            const user = window.auth.currentUser;
            if (user) {
                const idToken = await user.getIdToken(true);  // Force refresh
                localStorage.setItem('idToken', idToken);
                console.log('üîÑ [DEBUG] Token rafra√Æchi');
            }
        } catch (error) {
            console.error('‚ùå [DEBUG] Erreur refresh token:', error);
        }
    }

    async function handleLogout() {
        try {
            await window.auth.signOut();
            localStorage.removeItem('idToken');
            localStorage.removeItem('uid');
            window.location.href = '/auth.html';
        } catch (error) {
            console.error('Logout error:', error);
            showNotification('Logout error.', 'error');
        }
    }

    function formatTweetText(text) {
        const urlRegex = /(https?:\/\/[^\s]+)/g;
        let formatted = text.replace(urlRegex, '<a href="$1" target="_blank">$1</a>');
        return DOMPurify.sanitize(formatted, { ALLOWED_TAGS: ['a'], ALLOWED_ATTR: ['href', 'target'] });
    }

    function formatDate(date) {
        return new Intl.DateTimeFormat('en-US', {
            day: 'numeric',
            month: 'short',
            hour: '2-digit',
            minute: '2-digit',
            timeZone: 'Africa/Lagos'
        }).format(date);
    }

 function updateStyleProgress() {
    const maxProgress = 10000;
    styleProgress = Math.min(styleProgress, maxProgress);
    const progressPercentage = (styleProgress / maxProgress) * 100;
    document.getElementById('styleProgressBar').style.width = `${progressPercentage}%`;
    document.getElementById('styleProgressText').textContent = `${styleProgress}/${maxProgress}`;
    console.log('üìà [DEBUG] Progress bar updated:', styleProgress, progressPercentage); // Debug
}

   async function fetchUserStats() {
    try {
        const response = await fetch(`${BASE_URL}/api/user-stats`, {
            headers: { 'Authorization': `Bearer ${localStorage.getItem('idToken')}` }
        });
        const data = await response.json();
        console.log('üìä [DEBUG] User stats response:', data); // Debug
        if (data.success && data.data) {
            styleProgress = data.data.styleProgress || 0;
            console.log('üìà [DEBUG] styleProgress set to:', styleProgress); // Debug
            updateStyleProgress();
        } else {
            console.warn('‚ö†Ô∏è [DEBUG] No valid stats data received');
        }
    } catch (error) {
        console.error('‚ùå [DEBUG] Stats fetch error:', error);
    }
}

    function showNotification(message, type = 'success') {
        const notification = document.getElementById('notification');
        const messageElement = document.getElementById('notificationMessage');
        if (messageElement) {
            messageElement.textContent = message;
            notification.className = `notification ${type} show`;
            setTimeout(() => notification.classList.remove('show'), 3000);
        }
    }

    async function checkServerStatus() {
        const maxRetries = 3;
        let retries = 0;
        while (retries < maxRetries) {
            try {
                const response = await fetch(`${BASE_URL}/health`, {
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('idToken')}` },
                    signal: AbortSignal.timeout(5000)
                });
                if (response.ok) {
                    const data = await response.json();
                    document.getElementById('status').textContent = `Server connected ‚úì (v${data.version || '1.0'})`;
                    document.getElementById('status').className = 'status online';
                    return true;
                }
                throw new Error('Server unreachable');
            } catch (error) {
                retries++;
                if (retries === maxRetries) {
                    document.getElementById('status').textContent = 'Server disconnected ‚úó';
                    document.getElementById('status').className = 'status offline';
                    showNotification('Unable to connect to server.');
                    return false;
                }
                await new Promise(resolve => setTimeout(resolve, 2000));
            }
        }
    }

   async function fetchWithRetry(url, options = {}, retries = 3) {
    for (let i = 0; i < retries; i++) {
        try {
            options.headers = { ...options.headers, 'Authorization': `Bearer ${localStorage.getItem('idToken')}` };
            console.log('üì° [DEBUG] Fetch attempt:', { url, attempt: i + 1, headers: options.headers });
            const response = await fetch(url, options);
            if (!response) {
                throw new Error('No response received from server');
            }
            if (response.status === 401) {
                console.log('üîí [DEBUG] 401 Unauthorized, refreshing token...');
                await refreshIdToken();
                options.headers['Authorization'] = `Bearer ${localStorage.getItem('idToken')}`;
                continue;
            }
            return response;
        } catch (error) {
            console.error(`‚ùå [DEBUG] Fetch error on attempt ${i + 1}:`, error.message);
            if (i === retries - 1) {
                throw new Error(`Failed after ${retries} retries: ${error.message}`);
            }
            await new Promise(r => setTimeout(r, 1000 * (i + 1)));
        }
    }
}

    async function loadTweets(isManual = false) {
    if (!checkAuth()) return;
    if (isLoading || isEditing || (isManual && Date.now() - lastRefreshAttempt < MIN_REFRESH_INTERVAL)) return;

    isLoading = true;
    lastRefreshAttempt = Date.now();
    const container = document.getElementById('tweets-container');
    const refreshBtn = document.getElementById('refreshBtn');

    console.log('üîÑ [DEBUG] D√©but loadTweets'); // Debug

    if (isManual) {
        refreshBtn.disabled = true;
        refreshBtn.textContent = 'Loading...';
    }

    // Sauvegarde edits
    document.querySelectorAll('.tweet-content[data-dirty="true"]').forEach(textarea => {
        const [_, tweetId, tweetIndex] = textarea.id.split('_');
        saveTweetEdit(tweetId, parseInt(tweetIndex), textarea.value.trim());
    });

    const maxRetries = 3;
    let retryCount = 0;

    async function attemptFetch() {
        try {
            const headers = {
                'Authorization': `Bearer ${localStorage.getItem('idToken')}`,
                ...(lastETag ? { 'If-None-Match': lastETag } : {})
            };
            const response = await fetchWithRetry(`${BASE_URL}/api/tweets-history`, { headers, signal: AbortSignal.timeout(5000) });

            console.log('üì° [DEBUG] Response status:', response.status); // Debug

            if (response.status === 401) {
                window.location.href = '/auth.html';
                return null;
            }
            if (response.status === 304) {
                console.log('‚ÑπÔ∏è Data unchanged');
                return null;
            }
            if (!response.ok) throw new Error(`Network error: ${response.status}`);

            const data = await response.json();
            console.log('üì¶ [DEBUG] Data re√ßue:', data); // Debug
            lastETag = response.headers.get('ETag');
            return data;
        } catch (error) {
            console.error('‚ùå [DEBUG] Fetch error:', error); // Debug
            if (retryCount < maxRetries) {
                retryCount++;
                console.log(`Attempt ${retryCount}/${maxRetries} failed, retrying...`);
                await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
                return attemptFetch();
            }
            throw error;
        }
    }

    try {
        const data = await attemptFetch();
        if (data && data.success && data.data && data.data.length > 0) {
            tweetsDataCache = data.data;
            await loadScheduledTweets();
            displayTweets(tweetsDataCache);
            lastUpdateTime = Date.now();
            console.log('‚úÖ [DEBUG] Tweets affich√©s'); // Debug
        } else if (!data) {
            return;
        } else {
            tweetsDataCache = [];
            container.innerHTML = '<div class="no-tweets">No tweets generated.<br>Use the extension on Twitter/X!</div>';
            console.log('‚ö†Ô∏è [DEBUG] No data'); // Debug
        }
    } catch (error) {
        console.error('Tweet loading error:', error);
        container.innerHTML = '<div class="no-tweets">Tweet loading error.<br>Check if the server is working.</div>';
        showNotification('Tweet loading error.');
    } finally {
        isLoading = false;
        if (isManual) {
            refreshBtn.disabled = false;
            refreshBtn.textContent = 'Refresh';
        }
    }
}

    function displayTweets(tweetsData) {
        const container = document.getElementById('tweets-container');
        if (!tweetsData || tweetsData.length === 0) {
            container.innerHTML = '<div class="no-tweets">No tweets generated</div>';
            return;
        }

        let allTweets = [];
        tweetsData.forEach(tweetGroup => {
            if (!tweetGroup.generatedTweets || tweetGroup.generatedTweets.length === 0) return;

            const filteredTweets = selectedFilter
                ? tweetGroup.generatedTweets.map((tweet, index) => ({
                      tweet,
                      index,
                      mode: (tweetGroup.modesUsed && tweetGroup.modesUsed[index]) || 'unknown'
                  })).filter(item => item.mode === selectedFilter)
                : tweetGroup.generatedTweets.map((tweet, index) => ({
                      tweet,
                      index,
                      mode: (tweetGroup.modesUsed && tweetGroup.modesUsed[index]) || 'unknown'
                  }));

            filteredTweets.forEach(item => {
                allTweets.push({ ...item, tweetGroup });
            });
        });

        if (allTweets.length === 0) {
            container.innerHTML = '<div class="no-tweets">No tweets match the filter</div>';
            return;
        }

        let html = '<div class="tweets-grid">';
        const userPhoto = document.getElementById('userPhoto').src;

        allTweets.forEach(({ tweet, index, mode, tweetGroup }) => {
            const tweetId = `tweet_${tweetGroup.id}_${index}`;
            const cleanMode = mode === 'style-personnel' ? 'Personal Style' : mode.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            const timestamp = formatDate(new Date(tweetGroup.timestamp));
            const scheduleKey = `${tweetGroup.id}_${index}`;
            const tweetInfo = scheduledTweets.find(t => `${t.tweetId}_${t.tweetIndex}` === scheduleKey);
            let statusText, statusClass, scheduleDate;

            if (tweetInfo) {
                switch(tweetInfo.status) {
                    case 'scheduled':
                        statusClass = 'status-scheduled';
                        statusText = tweetInfo.datetime <= new Date() ? 'In progress...' : 'Scheduled';
                        scheduleDate = formatDate(new Date(tweetInfo.datetime));
                        break;
                    case 'published':
                        statusClass = 'status-published';
                        statusText = 'Published';
                        break;
                    case 'failed':
                        statusClass = 'status-failed';
                        statusText = 'Failed';
                        break;
                    default:
                        statusClass = '';
                        statusText = '';
                }
            } else {
                statusClass = '';
                statusText = '';
            }

            html += `
                <div class="tweet-item" id="${tweetId}_container">
                    <div class="badge-timestamp">
                        <div class="mode-badge">${cleanMode}</div>
                        <div class="timestamp">
                            ${timestamp}
                            ${statusText ? `<span class="status-indicator ${statusClass}"></span><span style="font-size: 10px; color: #888;">${statusText}${scheduleDate ? ` on ${scheduleDate}` : ''}</span>` : ''}
                        </div>
                    </div>
                    <div class="tweet-post" onclick="toggleEdit('${tweetId}')">
                        <img src="${userPhoto}" alt="Profile">
                        <div class="tweet-post-content">${formatTweetText(tweet)}</div>
                    </div>
                    <textarea class="tweet-content" id="${tweetId}" placeholder="Your tweet..." data-dirty="false">${tweet}</textarea>
                    <div class="media-upload-container" id="media-upload-${tweetId}" style="display: none;">
                        <div class="media-upload" onclick="document.getElementById('media-input-${tweetId}').click()">
                            <input type="file" id="media-input-${tweetId}" accept="image/jpeg,image/png,video/mp4" multiple>
                            <div>üì∑ Add media (images/videos)</div>
                            <div style="font-size: 10px; color: #666; margin-top: 5px;">
                                Click to select files (max 4)
                            </div>
                        </div>
                        <div class="media-preview" id="media-preview-${tweetId}"></div>
                    </div>
                    <div class="tweet-meta">
                        <span id="count_${tweetId}">${tweet.length}/280</span>
                        <div class="button-group">
                            <button class="copy-btn" onclick="copyTweet('${tweetId}')">
                             <svg width="30px" height="30px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <path d="M20.9983 10C20.9862 7.82497 20.8897 6.64706 20.1213 5.87868C19.2426 5 17.8284 5 15 5H12C9.17157 5 7.75736 5 6.87868 5.87868C6 6.75736 6 8.17157 6 11V16C6 18.8284 6 20.2426 6.87868 21.1213C7.75736 22 9.17157 22 12 22H15C17.8284 22 19.2426 22 20.1213 21.1213C21 20.2426 21 18.8284 21 16V15" stroke="#1C274C" stroke-width="1.5" stroke-linecap="round"></path> <path d="M3 10V16C3 17.6569 4.34315 19 6 19M18 5C18 3.34315 16.6569 2 15 2H11C7.22876 2 5.34315 2 4.17157 3.17157C3.51839 3.82475 3.22937 4.69989 3.10149 6" stroke="#1C274C" stroke-width="1.5" stroke-linecap="round"></path> </g></svg>
                            </button>
                            <button class="regen-btn" onclick="regenerateTweet('${tweetGroup.id}', ${index}, '${mode}')">
<svg width="20px" height="20px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <path d="M12 3L13.4302 8.31181C13.6047 8.96 13.692 9.28409 13.8642 9.54905C14.0166 9.78349 14.2165 9.98336 14.451 10.1358C14.7159 10.308 15.04 10.3953 15.6882 10.5698L21 12L15.6882 13.4302C15.04 13.6047 14.7159 13.692 14.451 13.8642C14.2165 14.0166 14.0166 14.2165 13.8642 14.451C13.692 14.7159 13.6047 15.04 13.4302 15.6882L12 21L10.5698 15.6882C10.3953 15.04 10.308 14.7159 10.1358 14.451C9.98336 14.2165 9.78349 14.0166 9.54905 13.8642C9.28409 13.692 8.96 13.6047 8.31181 13.4302L3 12L8.31181 10.5698C8.96 10.3953 9.28409 10.308 9.54905 10.1358C9.78349 9.98336 9.98336 9.78349 10.1358 9.54905C10.308 9.28409 10.3953 8.96 10.5698 8.31181L12 3Z" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path> </g></svg>
                            </button>
                            <button class="schedule-btn" onclick="openScheduleDialog('${tweetGroup.id}', ${index})">
                                <svg width="20px" height="20px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <path d="M18 2V4M6 2V4" stroke="#000000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path> <path d="M11.5 18L12.5 18M11.5 18C11.5 18.5523 11.0523 19 10.5 19C9.94771 19 9.5 18.5523 9.5 18M11.5 18C11.5 17.4477 11.0523 17 10.5 17C9.94771 17 9.5 17.4477 9.5 18M11.5 18L9.5 18" stroke="#000000" stroke-width="1.5" stroke-linejoin="round"></path> <path d="M20.5 7.00001L3.49998 7.00001" stroke="#000000" stroke-width="1.5" stroke-linecap="round"></path> <path d="M8 6C8 5.06812 8 4.60218 8.15224 4.23463C8.35523 3.74458 8.74458 3.35523 9.23463 3.15224C9.60218 3 10.0681 3 11 3H13C13.9319 3 14.3978 3 14.7654 3.15224C15.2554 3.35523 15.6448 3.74458 15.8478 4.23463C16 4.60218 16 5.06812 16 6V7C16 7.93188 16 8.39782 15.8478 8.76537C15.6448 9.25542 15.2554 9.64477 14.7654 9.84776C14.3978 10 13.9319 10 13 10H11C10.0681 10 9.60218 10 9.23463 9.84776C8.74458 9.64477 8.35523 9.25542 8.15224 8.76537C8 8.39782 8 7.93188 8 7V6Z" stroke="#000000" stroke-width="1.5"></path> <path d="M21.5 11.5C21.5 10.6716 20.8284 10 20 10H4C3.17157 10 2.5 10.6716 2.5 11.5V17C2.5 19.7614 4.73858 22 7.5 22H16.5C19.2614 22 21.5 19.7614 21.5 17V11.5Z" stroke="#000000" stroke-width="1.5"></path> </g></svg>
                            </button>
                            <button class="media-btn" onclick="toggleMediaUpload('${tweetId}')">
                                <svg width="20px" height="20px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <path d="M13.5 9C13.5 8.17157 12.8284 7.5 12 7.5C11.1716 7.5 10.5 8.17157 10.5 9C10.5 9.82843 11.1716 10.5 12 10.5C12.8284 10.5 13.5 9.82843 13.5 9Z" fill="#000000"></path> <path fill-rule="evenodd" clip-rule="evenodd" d="M7.25 3C4.35051 3 2 5.35051 2 8.25V15.75C2 18.6495 4.35051 21 7.25 21H16.75C19.6495 21 22 18.6495 22 15.75V8.25C22 5.35051 19.6495 3 16.75 3H7.25ZM3.5 8.25C3.5 6.17893 5.17893 4.5 7.25 4.5H16.75C18.8211 4.5 20.5 6.17893 20.5 8.25V15.75C20.5 17.8211 18.8211 19.5 16.75 19.5H7.25C5.17893 19.5 3.5 17.8211 3.5 15.75V8.25Z" fill="#000000"></path> </g></svg>
                            </button>
                            <button class="delete-btn" onclick="deleteTweet('${tweetGroup.id}', ${index})">
                                <svg width="20px" height="20px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <path d="M4 7H20" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path> <path d="M6 10L7.70141 19.3578C7.87432 20.3088 8.70258 21 9.66915 21H14.3308C15.2974 21 16.1257 20.3087 16.2986 19.3578L18 10" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path> <path d="M9 5C9 3.89543 9.89543 3 11 3H13C14.1046 3 15 3.89543 15 5V7H9V5Z" stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path> </g></svg>
                            </button>
                        </div>
                    </div>
                </div>`;
        });

        html += '</div>';
        container.innerHTML = html;

        // Add event listeners for textareas
        document.querySelectorAll('.tweet-content').forEach(textarea => {
            textarea.addEventListener('input', updateCharCount);
            textarea.addEventListener('focus', () => { isEditing = true; });
            textarea.addEventListener('blur', () => {
                isEditing = false;
                const [_, tweetId, tweetIndex] = textarea.id.split('_');
                if (textarea.dataset.dirty === 'true') {
                    saveTweetEdit(tweetId, parseInt(tweetIndex), textarea.value.trim());
                }
            });
        });


//fonctions a caher pour alleger

 // Add event listeners for media inputs
        document.querySelectorAll('.media-upload input').forEach(input => {
            input.addEventListener('change', (e) => {
                const tweetId = e.target.id.replace('media-input-', '');
                const [_, tweetGroupId, tweetIndex] = tweetId.split('_');
                const scheduleKey = `${tweetGroupId}_${tweetIndex}`;
                let mediaList = selectedMedia.get(scheduleKey) || [];
                if (mediaList.length >= 4) {
                    showNotification('Maximum 4 media per tweet.');
                    return;
                }
                const newFiles = Array.from(e.target.files);
                if (mediaList.length + newFiles.length > 4) {
                    showNotification(`Maximum 4 media. ${4 - mediaList.length} file(s) remaining.`);
                    return;
                }
                newFiles.forEach(file => {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const mediaItem = {
                            id: Date.now() + Math.random(),
                            file,
                            url: e.target.result,
                            type: file.type.startsWith('image/') ? 'image' : 'video',
                            mimetype: file.type
                        };
                        mediaList.push(mediaItem);
                        selectedMedia.set(scheduleKey, mediaList);
                        renderMediaPreview(tweetId, scheduleKey);
                    };
                    reader.readAsDataURL(file);
                });
                e.target.value = '';
            });
        });

        // Render media previews
        document.querySelectorAll('.media-preview').forEach(preview => {
            const tweetId = preview.id.replace('media-preview-', '');
            const scheduleKey = tweetId.replace('tweet_', '');
            renderMediaPreview(tweetId, scheduleKey);
        });
    }

    function toggleMediaUpload(tweetId) {
        const mediaContainer = document.getElementById(`media-upload-${tweetId}`);
        mediaContainer.style.display = mediaContainer.style.display === 'block' ? 'none' : 'block';
        if (mediaContainer.style.display === 'block') {
            const scheduleKey = tweetId.replace('tweet_', '');
            renderMediaPreview(tweetId, scheduleKey);
        }
    }

    function renderMediaPreview(tweetId, scheduleKey) {
        const mediaPreview = document.getElementById(`media-preview-${tweetId}`);
        if (!mediaPreview) return;

        const clientMedia = selectedMedia.get(scheduleKey) || [];
        const serverMedia = scheduledTweets.find(t => `${t.tweetId}_${t.tweetIndex}` === scheduleKey)?.media || [];
        const mergedMedia = [
            ...serverMedia.filter(m => m && m.filename && m.mimetype).map(m => ({
                id: m.id || (m.filename + Math.random()),
                url: m.url || `${BASE_URL}/uploads/${m.filename}`,
                type: m.type || (m.mimetype && m.mimetype.startsWith('image/') ? 'image' : 'video'),
                server: true,
                mimetype: m.mimetype
            })),
            ...clientMedia.filter(m => !m.server)
        ].slice(0, 4);

        mediaPreview.innerHTML = mergedMedia.map(media => `
            <div class="media-item" data-media-id="${media.id}">
                ${media.type === 'image'
                    ? `<img src="${media.url}" alt="Preview">`
                    : `<video src="${media.url}" controls style="width: 100%; height: 80px;"></video>`
                }
                ${!media.server ? `<button class="media-remove" data-schedule-key="${scheduleKey}" data-media-id="${media.id}">√ó</button>` : ''}
            </div>
        `).join('');

        mediaPreview.querySelectorAll('.media-remove').forEach(button => {
            button.addEventListener('click', () => {
                const scheduleKey = button.dataset.scheduleKey;
                const mediaId = parseFloat(button.dataset.mediaId);
                removeMedia(scheduleKey, mediaId, button);
            });
        });
    }

    function removeMedia(scheduleKey, mediaId, button) {
        button.disabled = true;
        button.style.background = 'rgba(0,0,0,0.05)';
        let mediaList = selectedMedia.get(scheduleKey) || [];
        const originalLength = mediaList.length;
        mediaList = mediaList.filter(media => media.id !== mediaId);
        if (mediaList.length < originalLength) {
            selectedMedia.set(scheduleKey, mediaList);
            const tweetId = `tweet_${scheduleKey}`;
            renderMediaPreview(tweetId, scheduleKey);
            showNotification('Media removed.');
        } else {
            showNotification('Error removing media.', 'error');
        }
        button.disabled = false;
        button.style.background = 'rgba(0,0,0,0.1)';
    }

    function toggleEdit(tweetId) {
        const textarea = document.getElementById(tweetId);
        const tweetPost = textarea.closest('.tweet-item').querySelector('.tweet-post');

        if (textarea.style.display === 'none' || !textarea.style.display) {
            textarea.style.display = 'block';
            tweetPost.style.display = 'none';
            textarea.focus();
            textarea.setSelectionRange(textarea.value.length, textarea.value.length);
        } else {
            textarea.style.display = 'none';
            tweetPost.style.display = 'flex';

            const [_, tweetGroupId, tweetIndex] = tweetId.split('_');
            if (textarea.dataset.dirty === 'true') {
                saveTweetEdit(tweetGroupId, parseInt(tweetIndex), textarea.value.trim());
            }
        }
    }

    async function deleteTweet(tweetId, tweetIndex) {
        if (!checkAuth()) return;
        if (!confirm('Do you really want to delete this tweet?')) return;

        const tweetElement = document.getElementById(`tweet_${tweetId}_${tweetIndex}_container`);
        const deleteBtn = tweetElement.querySelector('.delete-btn');
        const originalContent = deleteBtn.innerHTML;

        deleteBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle></svg>';
        deleteBtn.disabled = true;

        const scheduleKey = `${tweetId}_${tweetIndex}`;
        const tweetInfo = scheduledTweets.find(t => `${t.tweetId}_${t.tweetIndex}` === scheduleKey);

        const maxRetries = 3;
        let retryCount = 0;

        async function attemptDelete() {
            try {
                if (tweetInfo) {
                    const response = await fetchWithRetry(`${BASE_URL}/api/tweets/${tweetInfo.id}`, {
                        method: 'DELETE',
                        headers: {
                            'Authorization': `Bearer ${localStorage.getItem('idToken')}`
                        },
                        signal: AbortSignal.timeout(5000)
                    });
                    if (!response.ok) {
                        const result = await response.json();
                        throw new Error(result.error || `Network error: ${response.status}`);
                    }
                    scheduledTweets = scheduledTweets.filter(t => `${t.tweetId}_${t.tweetIndex}` !== scheduleKey);
                    tweetSchedules.delete(scheduleKey);
                    selectedMedia.delete(scheduleKey);
                }

                const response = await fetch(`${BASE_URL}/api/delete-tweet`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('idToken')}`
                    },
                    body: JSON.stringify({ tweetId, tweetIndex }),
                    signal: AbortSignal.timeout(5000)
                });

                if (response.status === 401) {
                    window.location.href = '/auth.html';
                    return;
                }

                const result = await response.json();
                if (!response.ok) {
                    throw new Error(result.error || `Network error: ${response.status}`);
                }

                if (result.success) {
                    tweetElement.remove();
                    const group = tweetsDataCache.find(g => g.id === tweetId);
                    if (group) {
                        group.generatedTweets.splice(tweetIndex, 1);
                        if (group.modesUsed) group.modesUsed.splice(tweetIndex, 1);
                        group.lastModified = result.data?.lastModified;
                        if (group.generatedTweets.length === 0) {
                            tweetsDataCache = tweetsDataCache.filter(g => g.id !== tweetId);
                        }
                    }
                    displayTweets(tweetsDataCache);
                    showNotification('Tweet deleted successfully!', 'success');
                    if (!document.querySelector('.tweet-item')) {
                        document.getElementById('tweets-container').innerHTML = '<div class="no-tweets">No tweets generated</div>';
                    }
                } else {
                    throw new Error(result.error || 'Unknown error');
                }
            } catch (error) {
                if (retryCount < maxRetries) {
                    retryCount++;
                    console.log(`Attempt ${retryCount}/${maxRetries} failed for deletion, retrying...`);
                    await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
                    return attemptDelete();
                }
                throw error;
            }
        }

        try {
            await attemptDelete();
        } catch (error) {
            console.error('Tweet deletion error:', error);
            showNotification(`Error: ${error.message}.`);
            deleteBtn.innerHTML = originalContent;
            deleteBtn.disabled = false;
        }
    }

    function updateCharCount(event) {
        const textarea = event.target;
        const countElement = document.getElementById(`count_${textarea.id}`);
        if (countElement) {
            const length = textarea.value.length;
            countElement.textContent = `${length}/280`;
            countElement.style.color = length > 280 ? '#dc3545' : length > 250 ? '#ffc107' : '#6c757d';
            textarea.dataset.dirty = 'true';

            // Update tweet display
            const tweetElement = textarea.closest('.tweet-item');
            const postContent = tweetElement.querySelector('.tweet-post-content');
            postContent.innerHTML = formatTweetText(textarea.value);
        }
    }

    async function saveTweetEdit(tweetId, tweetIndex, newText) {
        if (!checkAuth()) return;
        if (!newText) {
            showNotification('Tweet cannot be empty.');
            return;
        }
        if (newText.length > 280) {
            showNotification('Tweet exceeds 280 characters.');
            return;
        }

        const textarea = document.getElementById(`tweet_${tweetId}_${tweetIndex}`);
        const maxRetries = 3;
        let retryCount = 0;

        async function attemptSave() {
            try {
                textarea.disabled = true;
                textarea.classList.add('loading-pulse');

                const response = await fetch(`${BASE_URL}/api/edit-tweet`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('idToken')}`
                    },
                    body: JSON.stringify({ tweetId, tweetIndex, newText }),
                    signal: AbortSignal.timeout(5000)
                });

                if (response.status === 401) {
                    window.location.href = '/auth.html';
                    return;
                }

                const result = await response.json();
                if (!response.ok) throw new Error(result.error || `Network error: ${response.status}`);

                if (result.success) {
                    textarea.dataset.dirty = 'false';
                    updateCharCount({ target: textarea });
                    styleProgress = result.data.styleProgress || styleProgress;
                    updateStyleProgress();
                    showNotification('Tweet modified successfully!', 'success');

                    const group = tweetsDataCache.find(g => g.id === tweetId);
                    if (group) {
                        group.generatedTweets[tweetIndex] = newText;
                        group.lastModified = result.data?.lastModified;
                    }
                    const scheduleKey = `${tweetId}_${tweetIndex}`;
                    const tweetInfo = scheduledTweets.find(t => `${t.tweetId}_${t.tweetIndex}` === scheduleKey);
                    if (tweetInfo) {
                        tweetInfo.content = newText;
                    }
                    displayTweets(tweetsDataCache);
                } else {
                    throw new Error(result.error || 'Unknown error');
                }
            } catch (error) {
                if (retryCount < maxRetries) {
                    retryCount++;
                    console.log(`Attempt ${retryCount}/${maxRetries} failed for save, retrying...`);
                    await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
                    return attemptSave();
                }
                throw error;
            }
        }

        try {
            await attemptSave();
        } catch (error) {
            console.error('Tweet modification error:', error);
            showNotification(`Error: ${error.message}.`);
        } finally {
            textarea.disabled = false;
            textarea.classList.remove('loading-pulse');
        }
    }

    async function copyTweet(tweetId) {
        const textarea = document.getElementById(tweetId);
        const tweetElement = textarea.closest('.tweet-item');
        const copyBtn = tweetElement.querySelector('.copy-btn');
        const originalContent = copyBtn.innerHTML;

        try {
            await navigator.clipboard.writeText(textarea.value);
            copyBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20,6 9,17 4,12"></polyline></svg>';
            copyBtn.classList.add('copied');
            tweetElement.style.background = 'linear-gradient(145deg, #f8f9fa, #e9ecef)';
            tweetElement.style.borderColor = '#ced4da';
            showNotification('Tweet copied!', 'success');

            setTimeout(() => {
                copyBtn.innerHTML = originalContent;
                copyBtn.classList.remove('copied');
                tweetElement.style.background = 'linear-gradient(145deg, #ffffff, #f8f9fa)';
                tweetElement.style.borderColor = '#dee2e6';
            }, 2000);
        } catch (error) {
            console.error('Copy error:', error);
            showNotification('Copy error.', 'error');
            copyBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>';
            setTimeout(() => copyBtn.innerHTML = originalContent, 2000);
        }
    }

    async function regenerateTweet(tweetId, tweetIndex, mode) {
        if (!checkAuth()) return;

        const tweetElement = document.getElementById(`tweet_${tweetId}_${tweetIndex}_container`);
        const regenBtn = tweetElement.querySelector('.regen-btn');
        const originalContent = regenBtn.innerHTML;

        regenBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle></svg>';
        regenBtn.disabled = true;

        const maxRetries = 3;
        let retryCount = 0;

        async function attemptRegenerate() {
            try {
                const response = await fetch(`${BASE_URL}/api/regenerate-tweet`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('idToken')}`
                    },
                    body: JSON.stringify({ tweetId, tweetIndex, mode }),
                    signal: AbortSignal.timeout(5000)
                });

                if (response.status === 401) {
                    window.location.href = '/auth.html';
                    return;
                }

                const result = await response.json();
                if (!response.ok) throw new Error(result.error || 'Network error');

                if (result.success && result.data) {
                    const textarea = document.getElementById(`tweet_${tweetId}_${tweetIndex}`);
                    textarea.value = result.data.tweet;
                    textarea.dataset.dirty = 'false';
                    updateCharCount({ target: textarea });

                    regenBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20,6 9,17 4,12"></polyline></svg>';
                    regenBtn.classList.add('regenerated');

                    setTimeout(() => {
                        regenBtn.innerHTML = originalContent;
                        regenBtn.classList.remove('regenerated');
                        regenBtn.disabled = false;
                    }, 2000);

                    showNotification('Tweet regenerated successfully!', 'success');

                    const group = tweetsDataCache.find(g => g.id === tweetId);
                    if (group) {
                        group.generatedTweets[tweetIndex] = result.data.tweet;
                        if (group.modesUsed) group.modesUsed[tweetIndex] = mode;
                        group.lastModified = result.data?.lastModified;
                    }
                    displayTweets(tweetsDataCache);
                } else {
                    throw new Error(result.error || 'Unknown error');
                }
            } catch (error) {
                if (retryCount < maxRetries) {
                    retryCount++;
                    console.log(`Attempt ${retryCount}/${maxRetries} failed for regeneration, retrying...`);
                    await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
                    return attemptRegenerate();
                }
                throw error;
            }
        }

        try {
            await attemptRegenerate();
        } catch (error) {
            console.error('Regeneration error:', error);
            showNotification(`Error: ${error.message}.`, 'error');
            regenBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>';
            setTimeout(() => {
                regenBtn.innerHTML = originalContent;
                regenBtn.disabled = false;
            }, 2000);
        }
    }

    function openScheduleDialog(tweetId, tweetIndex) {
        currentTweetId = tweetId;
        currentTweetIndex = tweetIndex;
        const dialog = document.getElementById('schedule-dialog');
        const scheduleDate = document.getElementById('scheduleDate');
        const scheduleTime = document.getElementById('scheduleTime');
        const now = new Date();
        now.setMinutes(0, 0, 0);
        scheduleDate.min = now.toISOString().split('T')[0];
        scheduleDate.value = now.toISOString().split('T')[0];
        now.setHours(now.getHours() + 1);
        scheduleTime.value = now.toTimeString().slice(0, 5);
        dialog.style.display = 'flex';
        scheduleDate.focus();
    }

    function closeScheduleDialog() {
        document.getElementById('schedule-dialog').style.display = 'none';
        currentTweetId = null;
        currentTweetIndex = null;
    }

 async function confirmSchedule() {
    console.log('üéØ [DEBUG] confirmSchedule() appel√©e');

    if (!currentTweetId || currentTweetIndex === null) {
        console.log('‚ùå [DEBUG] Aucun tweet s√©lectionn√©:', { currentTweetId, currentTweetIndex });
        showNotification('No tweet selected.', 'error');
        return;
    }

    console.log('‚úÖ [DEBUG] Tweet s√©lectionn√©:', { currentTweetId, currentTweetIndex });

    const scheduleDate = document.getElementById('scheduleDate');
    const scheduleTime = document.getElementById('scheduleTime');
    const content = document.getElementById(`tweet_${currentTweetId}_${currentTweetIndex}`).value.trim();
    const scheduleKey = `${currentTweetId}_${currentTweetIndex}`;
    const tweetElement = document.getElementById(`tweet_${currentTweetId}_${currentTweetIndex}_container`);
    const scheduleBtn = tweetElement.querySelector('.schedule-btn');
    const originalContent = scheduleBtn.innerHTML;

    console.log('üìù [DEBUG] Contenu du tweet:', { content, length: content.length });

    // Validations basiques
    if (!content) {
        console.log('‚ùå [DEBUG] Tweet vide');
        showNotification('Tweet cannot be empty.', 'error');
        return;
    }
    if (content.length > 280) {
        console.log('‚ùå [DEBUG] Tweet trop long:', content.length);
        showNotification('Tweet exceeds 280 characters.', 'error');
        return;
    }
    if (!scheduleDate.value || !scheduleTime.value) {
        console.log('‚ùå [DEBUG] Date/heure manquante:', { date: scheduleDate.value, time: scheduleTime.value });
        showNotification('Please select date and time.', 'error');
        return;
    }

    const datetime = `${scheduleDate.value}T${scheduleTime.value}:00`;
    const scheduleDateTime = new Date(datetime);
    const now = new Date();

    console.log('‚è∞ [DEBUG] Validation date:', {
        datetime,
        scheduleDateTime: scheduleDateTime.toISOString(),
        now: now.toISOString(),
        isFuture: scheduleDateTime > now
    });

    if (scheduleDateTime <= now) {
        console.log('‚ùå [DEBUG] Date dans le pass√©');
        showNotification('Date must be in the future.', 'error');
        return;
    }

    // UI feedback de chargement
    scheduleBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle></svg>';
    scheduleBtn.disabled = true;

    const maxRetries = 3;
    let retryCount = 0;

    async function attemptSchedule() {
    console.log(`üîÑ [DEBUG] Tentative de scheduling ${retryCount + 1}/${maxRetries}`);
    try {
        await refreshIdToken(); // Refresh token before each attempt
        const formData = new FormData();
        formData.append('content', content);
        formData.append('datetime', datetime);
        formData.append('tweetId', currentTweetId);
        formData.append('tweetIndex', currentTweetIndex);

        const mediaItems = selectedMedia.get(scheduleKey) || [];
        console.log('üñºÔ∏è [DEBUG] M√©dias attach√©s:', mediaItems.length);

        mediaItems.forEach((media, index) => {
            if (media.file && media.mimetype) {
                console.log(`üìé [DEBUG] M√©dia ${index}:`, { name: media.file.name, type: media.mimetype });
                formData.append('media', media.file, media.file.name);
            }
        });

        console.log('üì° [DEBUG] Envoi requ√™te vers /api/admin/schedule-tweet...');

        const response = await fetch(`${BASE_URL}/api/admin/schedule-tweet`, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${localStorage.getItem('idToken')}`,
                'X-Admin-Key': 'Jareddenver08?'  // Ensure this matches your .env ADMIN_SECRET
            },
            body: formData,
            signal: AbortSignal.timeout(15000)
        });

        console.log('üì• [DEBUG] R√©ponse re√ßue:', {
            status: response.status,
            ok: response.ok,
            statusText: response.statusText
        });

        if (response.status === 401) {
            console.log('üîí [DEBUG] Token Firebase peut-√™tre expir√©, nouvelle tentative apr√®s refresh');
            await refreshIdToken();
            throw new Error('401 Unauthorized, retrying after token refresh');
        }

        const result = await response.json();
        console.log('üìã [DEBUG] R√©sultat parsing:', result);

        if (!response.ok) {
            console.log('‚ùå [DEBUG] Erreur serveur:', result.error);
            throw new Error(result.error || `Network error: ${response.status}`);
        }

        if (result.success) {
    console.log('üéâ [DEBUG] Scheduling r√©ussi !');

    // Mettre √† jour l'interface imm√©diatement
    const scheduleDateTime = new Date(datetime);
    tweetSchedules.set(scheduleKey, scheduleDateTime.toISOString());

    // Mettre √† jour le bouton avec l'ic√¥ne de succ√®s
    scheduleBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20,6 9,17 4,12"></polyline></svg>';

    // Mettre √† jour le timestamp imm√©diatement
    const timestampElement = tweetElement.querySelector('.timestamp');
    const createdAt = formatDate(new Date());
    const scheduledFor = formatDate(scheduleDateTime);
    timestampElement.innerHTML = `
        ${createdAt}
        <span class="status-indicator status-scheduled"></span>
        <span style="font-size: 10px; color: #888;">Scheduled on ${scheduledFor}</span>
    `;

    // Fermer la popup
    closeScheduleDialog();

    // Notification de succ√®s
    showNotification('Tweet scheduled successfully!', 'success');

    // Restaurer le bouton apr√®s 2 secondes
    setTimeout(() => {
        scheduleBtn.innerHTML = originalContent;
        scheduleBtn.disabled = false;
    }, 2000);

    // Recharger les donn√©es apr√®s 3 secondes pour avoir les derni√®res infos
    setTimeout(() => {
        loadScheduledTweets();
    }, 3000);

    return; // Important pour sortir de la fonction
}else {
            console.log('‚ùå [DEBUG] √âchec scheduling serveur:', result.error);
            throw new Error(result.error || 'Unknown scheduling error');
        }
    } catch (error) {
        console.error(`‚ùå [DEBUG] Erreur tentative ${retryCount + 1}:`, error.message);
        if (retryCount < maxRetries) {
            retryCount++;
            console.log(`üîÑ [DEBUG] Retry ${retryCount}/${maxRetries} dans ${1000 * retryCount}ms...`);
            await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
            return attemptSchedule();
        }
        throw error;
    }
}

    try {
        await attemptSchedule();
    } catch (error) {
        console.error('üí• [DEBUG] √âchec final scheduling:', error);
        showNotification(`Error: ${error.message}`, 'error');
        scheduleBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>';
        setTimeout(() => {
            scheduleBtn.innerHTML = originalContent;
            scheduleBtn.disabled = false;
        }, 2000);
    }
}
// Ajoutez cette fonction quelque part dans votre code
function startAutoRefresh() {
    // Rafra√Æchir les tweets toutes les 30 secondes
    setInterval(() => {
        if (!isEditing) { // Ne pas rafra√Æchir si l'utilisateur √©dite
            console.log('üîÑ Auto-refresh des tweets programm√©s...');
            loadScheduledTweets();
        }
    }, 30000); // 30 secondes
}

// Appelez cette fonction apr√®s le chargement initial
document.addEventListener('DOMContentLoaded', () => {
    // Vos autres initialisations...
    startAutoRefresh();
});
    //new
    async function sendTwitterTokensToServer(user, credential) {
        console.log('üê¶ [DEBUG] sendTwitterTokensToServer() appel√©e');
        console.log('üë§ [DEBUG] User Firebase:', { uid: user.uid, displayName: user.displayName });
        console.log('üîë [DEBUG] Credential re√ßu:', !!credential);

        try {
            const idToken = await user.getIdToken();
            console.log('üé´ [DEBUG] ID Token Firebase r√©cup√©r√©');

            // Extraire les tokens Twitter du credential
            let twitterAccessToken = null;
            let twitterSecret = null;

            if (credential && credential.accessToken && credential.secret) {
                // OAuth 1.0a (Twitter v1)
                twitterAccessToken = credential.accessToken;
                twitterSecret = credential.secret;
                console.log('üîê [DEBUG] Tokens Twitter OAuth 1.0a extraits');
            } else if (credential && credential.accessToken) {
                // OAuth 2.0 (Twitter v2)
                twitterAccessToken = credential.accessToken;
                console.log('üîê [DEBUG] Token Twitter OAuth 2.0 extrait');
            } else {
                console.log('‚ö†Ô∏è [DEBUG] Aucun token Twitter trouv√© dans credential');
            }

            const payload = {
                twitterAccessToken,
                twitterSecret,
                userInfo: {
                    uid: user.uid,
                    displayName: user.displayName,
                    email: user.email,
                    photoURL: user.photoURL
                }
            };

            console.log('üì§ [DEBUG] Envoi vers /api/login:', {
                hasTwitterToken: !!twitterAccessToken,
                hasTwitterSecret: !!twitterSecret,
                uid: user.uid
            });

            const response = await fetch(`${BASE_URL}/api/login`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${idToken}`
                },
                body: JSON.stringify(payload)
            });

            console.log('üì• [DEBUG] R√©ponse /api/login:', {
                status: response.status,
                ok: response.ok
            });

            const result = await response.json();
            console.log('üìã [DEBUG] R√©sultat /api/login:', result);

            if (result.success) {
                console.log('‚úÖ [DEBUG] Connexion serveur r√©ussie');
                console.log('üê¶ [DEBUG] Twitter connect√©:', result.twitterConnected);

                // Stocker les infos localement si n√©cessaire
                if (result.twitterUser) {
                    console.log('üë§ [DEBUG] Info Twitter user:', result.twitterUser);
                }

                return result;
            } else {
                console.error('‚ùå [DEBUG] √âchec connexion serveur:', result.error);
                throw new Error(result.error || '√âchec connexion serveur');
            }

        } catch (error) {
            console.error('üí• [DEBUG] Erreur sendTwitterTokensToServer:', error);
            throw error;
        }
    }
    //mew


  async function checkTwitterStatus() {
    console.log('üîç [DEBUG] V√©rification statut Twitter...');
    try {
        const response = await fetch(`${BASE_URL}/api/admin/twitter-status`, {
            headers: {
                'Authorization': `Bearer ${localStorage.getItem('idToken')}`,
                'X-Admin-Key': 'Jareddenver08?'  // Remplace par ta vraie cl√© admin de .env
            }
        });
        const status = await response.json();
        console.log('üìä [DEBUG] Statut Twitter:', status);
        if (status.authenticated && status.user) {
            console.log('‚úÖ [DEBUG] Twitter connect√©:', status.user.handle);
        } else {
            console.log('‚ö†Ô∏è [DEBUG] Twitter non connect√©');
        }
        return status;
    } catch (error) {
        console.error('‚ùå [DEBUG] Erreur v√©rification Twitter:', error);
        return { authenticated: false };
    }
}

async function authenticateTwitter() {
    try {
        console.log('üîÑ D√©but authentification Twitter...');
        const token = localStorage.getItem('idToken');
        if (!token) {
            throw new Error('Utilisateur non authentifi√© avec Firebase');
        }
        const response = await fetch(`${BASE_URL}/api/admin/auth/twitter`, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json',
                'X-Admin-Key': 'Jareddenver08?'  // Remplace par ta vraie cl√© admin de .env
            }
        });
        const data = await response.json();
        if (!response.ok) {
            throw new Error(data.error || 'Erreur lors de la demande d\'authentification');
        }
        if (!data.success || !data.authUrl) {
            throw new Error('URL d\'authentification non re√ßue');
        }
        console.log('‚úÖ URL d\'authentification re√ßue:', data.authUrl);
        const authUrlWithToken = `${data.authUrl}&firebase_token=${encodeURIComponent(token)}`;
        const popup = window.open(
            authUrlWithToken,
            'twitter-auth',
            'width=600,height=700,scrollbars=yes,resizable=yes'
        );
        const checkClosed = setInterval(() => {
            if (popup.closed) {
                clearInterval(checkClosed);
                console.log('üîÑ Popup ferm√©e, v√©rification du statut...');
                checkTwitterStatus();
            }
        }, 1000);
    } catch (error) {
        console.error('‚ùå Erreur authentification Twitter:', error.message);
        showNotification(`Erreur d'authentification Twitter: ${error.message}`, 'error');
    }
}
    //new

    // Fonction pour d√©connecter Twitter
    async function disconnectTwitter() {
      try {
        const token = localStorage.getItem('idToken');
        if (!token) {
          throw new Error('Token Firebase manquant');
        }

        const response = await fetch(`${BASE_URL}/api/twitter-logout`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          }
        });

        const data = await response.json();

        if (data.success) {
          console.log('‚úÖ D√©connexion Twitter r√©ussie');
          updateTwitterUI(null);
        } else {
          throw new Error(data.error || 'Erreur lors de la d√©connexion');
        }
      } catch (error) {
        console.error('‚ùå Erreur d√©connexion Twitter:', error.message);
        showNotification(`Erreur de d√©connexion: ${error.message}`, 'error');
      }
    }
 async function checkTwitterConnectionStatus() {
    console.log('üîç [DEBUG] V√©rification statut Twitter...');
    try {
        const response = await fetch(`${BASE_URL}/api/admin/twitter-status`, {
            headers: {
                'Authorization': `Bearer ${localStorage.getItem('idToken')}`,
                'X-Admin-Key': 'Jareddenver08?'  // Remplace par ta vraie cl√© admin de .env
            }
        });
        const status = await response.json();
        console.log('üìä [DEBUG] Statut Twitter:', status);
        if (status.authenticated && status.user) {
            console.log('‚úÖ [DEBUG] Twitter connect√©:', status.user.handle);
            const twitterBtn = document.createElement('button');
            twitterBtn.id = 'twitter-auth-btn';
            twitterBtn.textContent = 'D√©connexion Twitter';
            twitterBtn.onclick = disconnectTwitter;
            document.querySelector('.page-header').appendChild(twitterBtn);
            loadTweets(true);
        } else {
            console.log('‚ö†Ô∏è [DEBUG] Twitter non connect√©');
            const twitterBtn = document.createElement('button');
            twitterBtn.id = 'twitter-auth-btn';
            twitterBtn.textContent = 'Connexion Twitter';
            twitterBtn.onclick = authenticateTwitter;
            document.querySelector('.page-header').appendChild(twitterBtn);
            showNotification('Connectez Twitter pour scheduler des tweets.', 'warning');
        }
    } catch (error) {
        console.error('‚ùå [DEBUG] Erreur check Twitter:', error);
        showNotification('Erreur v√©rification Twitter.', 'error');
    }
}

    // Appel au load
    checkTwitterConnectionStatus();
    async function fetchWithAut(url, options = {}) {
        try {
            options.headers = { ...options.headers, 'Authorization': `Bearer ${localStorage.getItem('idToken')}` };
            let response = await fetch(url, options);
            if (response.status === 401) {
                await refreshIdToken();
                options.headers['Authorization'] = `Bearer ${localStorage.getItem('idToken')}`;
                response = await fetch(url, options); // Retry once
            }
            return response;
        } catch (error) {
            throw error;
        }
    }
     function setupFilters() {
        const filterTags = document.querySelectorAll('.filter-tag');
        const clearFilter = document.getElementById('clearFilter');

        filterTags.forEach(tag => {
            tag.addEventListener('click', () => {
                if (tag.classList.contains('selected')) {
                    tag.classList.remove('selected');
                    selectedFilter = null;
                    clearFilter.classList.remove('show');
                } else {
                    filterTags.forEach(t => t.classList.remove('selected'));
                    tag.classList.add('selected');
                    selectedFilter = tag.dataset.filter;
                    clearFilter.classList.add('show');
                }
                displayTweets(tweetsDataCache);
            });
        });

        clearFilter.addEventListener('click', () => {
            filterTags.forEach(tag => tag.classList.remove('selected'));
            selectedFilter = null;
            clearFilter.classList.remove('show');
            displayTweets(tweetsDataCache);
        });
    }

    function setupCustomInput() {
        const customInputBtn = document.getElementById('customInputBtn');
        const customInput = document.getElementById('customInput');

        customInputBtn.addEventListener('click', (e) => {
            if (!customInputBtn.classList.contains('active')) {
                customInputBtn.classList.add('active');
                setTimeout(() => customInput.focus(), 300);
            }
        });

        document.addEventListener('click', (e) => {
            if (!customInputBtn.contains(e.target)) {
                customInputBtn.classList.remove('active');
            }
        });

        customInput.addEventListener('keypress', async (e) => {
            if (e.key === 'Enter' && customInput.value.trim()) {
                const message = customInput.value.trim();
                if (message.startsWith('#feedback')) {
                    await sendFeedback(message);
                } else {
                    await sendUserStyle(message);
                }
            }
        });

        updateStyleProgress();
    }
async function loadScheduledTweets() {
    try {
        console.log('üîÑ [DEBUG] Starting loadScheduledTweets');
        await refreshIdToken(); // Refresh token before fetch
        const headers = {
            'Authorization': `Bearer ${localStorage.getItem('idToken')}`,
            'X-Admin-Key': 'Jareddenver08?', // Ensure this matches your .env ADMIN_SECRET
            ...(lastETag ? { 'If-None-Match': lastETag } : {})
        };
        console.log('üì° [DEBUG] Fetching /api/admin/tweets with headers:', headers);
        const response = await fetchWithRetry(`${BASE_URL}/api/admin/tweets`, { headers, signal: AbortSignal.timeout(5000) });

        if (!response) {
            throw new Error('No response received from /api/admin/tweets');
        }

        if (response.status === 401) {
            console.log('üîí [DEBUG] 401 Unauthorized, retrying after token refresh');
            await refreshIdToken();
            headers['Authorization'] = `Bearer ${localStorage.getItem('idToken')}`;
            const retryResponse = await fetchWithRetry(`${BASE_URL}/api/admin/tweets`, { headers, signal: AbortSignal.timeout(5000) });
            if (!retryResponse) {
                throw new Error('No response received on retry');
            }
            if (!retryResponse.ok) {
                throw new Error(`Network error: ${retryResponse.status}`);
            }
            const tweets = await retryResponse.json();
            lastETag = retryResponse.headers.get('ETag');
            scheduledTweets = tweets.map(tweet => ({
                ...tweet,
                datetime: new Date(tweet.datetime),
                createdAt: new Date(tweet.createdAt),
                media: tweet.media ? tweet.media.map(m => ({
                    ...m,
                    id: m.id || (m.filename + Math.random()),
                    url: m.url || `${BASE_URL}/Uploads/admin/${m.filename}`,
                    type: m.type || (m.mimetype && m.mimetype.startsWith('image/') ? 'image' : 'video'),
                    server: true,
                    mimetype: m.mimetype
                })) : []
            }));
        } else if (response.status === 304) {
            console.log('‚ÑπÔ∏è [DEBUG] Scheduled tweets unchanged (304)');
            return;
        } else if (!response.ok) {
            throw new Error(`Network error: ${response.status}`);
        } else {
            const tweets = await response.json();
            lastETag = response.headers.get('ETag');
            scheduledTweets = tweets.map(tweet => ({
                ...tweet,
                datetime: new Date(tweet.datetime),
                createdAt: new Date(tweet.createdAt),
                media: tweet.media ? tweet.media.map(m => ({
                    ...m,
                    id: m.id || (m.filename + Math.random()),
                    url: m.url || `${BASE_URL}/Uploads/admin/${m.filename}`,
                    type: m.type || (m.mimetype && m.mimetype.startsWith('image/') ? 'image' : 'video'),
                    server: true,
                    mimetype: m.mimetype
                })) : []
            }));
        }

        tweetSchedules.clear();
        selectedMedia.clear();
        scheduledTweets.forEach(tweet => {
            const scheduleKey = `${tweet.tweetId}_${tweet.tweetIndex}`;
            tweetSchedules.set(scheduleKey, tweet.datetime.toISOString());
            if (tweet.media && tweet.media.length > 0) {
                selectedMedia.set(scheduleKey, tweet.media);
            }
        });

       // Remplacez la partie qui met √† jour les statuts dans loadScheduledTweets() par :
scheduledTweets.forEach(tweet => {
    const tweetElement = document.getElementById(`tweet_${tweet.tweetId}_${tweet.tweetIndex}_container`);
    if (tweetElement) {
        const timestampElement = tweetElement.querySelector('.timestamp');
        const now = new Date();
        let statusText, statusClass;

        switch(tweet.status) {
            case 'scheduled':
                statusClass = 'status-scheduled';
                // V√©rifier si le tweet devrait d√©j√† √™tre publi√©
                if (tweet.datetime <= now) {
                    statusText = 'Publishing...';
                    statusClass = 'status-publishing';
                } else {
                    statusText = 'Scheduled';
                }
                break;
            case 'publishing':
                statusClass = 'status-publishing';
                statusText = 'Publishing...';
                break;
            case 'published':
                statusClass = 'status-published';
                statusText = 'Published';
                break;
            case 'failed':
                statusClass = 'status-failed';
                statusText = 'Failed';
                break;
            default:
                statusClass = '';
                statusText = '';
        }

        const createdAt = formatDate(new Date(tweet.createdAt));
        const scheduleDate = tweet.status === 'scheduled' ? ` on ${formatDate(tweet.datetime)}` : '';

        timestampElement.innerHTML = `
            ${createdAt}
            ${statusText ? `<span class="status-indicator ${statusClass}"></span><span style="font-size: 10px; color: #888;">${statusText}${scheduleDate}</span>` : ''}
        `;

        const scheduleKey = `${tweet.tweetId}_${tweet.tweetIndex}`;
        renderMediaPreview(`tweet_${tweet.tweetId}_${tweet.tweetIndex}`, scheduleKey);
    }
});
        console.log('‚úÖ [DEBUG] Scheduled tweets loaded successfully');
    } catch (error) {
        console.error('‚ùå [DEBUG] Scheduled tweets loading error:', error.message);
        showNotification(`Error loading scheduled tweets: ${error.message}`, 'error');
    }
}
      async function sendFeedback(message) {
        const customInput = document.getElementById('customInput');
        if (!message) {
            showNotification('Please enter feedback.');
            return;
        }

        try {
            customInput.disabled = true;
            customInput.classList.add('loading-pulse');

            const response = await emailjs.send('service_v0fds5a', 'template_cd6fjit', {
                message,
                user_name: document.getElementById('userName').textContent,
                user_email: window.auth.currentUser?.email || 'noreply@example.com',
                to_email: 'toumoudagoujoseph@gmail.com',
                subject: 'Feedback'
            });

            if (response.status === 200) {
                customInput.value = '';
                customInput.placeholder = '‚úÖ Feedback sent!';
                setTimeout(() => customInput.placeholder = 'Enter #feedback or your style...', 5000);
                showNotification('Feedback sent successfully!', 'success');
            } else {
                throw new Error(`Unexpected error: ${response.status}`);
            }
        } catch (error) {
            console.error('Feedback sending error:', error);
            showNotification(`Error: ${error.message}`);
        } finally {
            customInput.disabled = false;
            customInput.classList.remove('loading-pulse');
        }
    }
//fin de des focntions a alleger


    // V√©rifier le statut au chargement de la page
 document.addEventListener('DOMContentLoaded', () => {
    console.log('üöÄ [DEBUG] Page admin.html charg√©e');
    if (!checkAuth()) return;

    setupFilters();
    const navItems = document.querySelectorAll('.nav-item');
    navItems.forEach(item => {
        item.addEventListener('click', (e) => {
            e.preventDefault();
            const tabId = item.dataset.tab;
            console.log('üîÑ [DEBUG] Switch to tab:', tabId);
            navItems.forEach(nav => nav.classList.remove('active'));
            item.classList.add('active');
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            const targetTab = document.getElementById(tabId);
            if (targetTab) {
                targetTab.classList.add('active');
            }
            if (tabId === 'twitter') {
                loadTweets(true);
            }
        });
    });

    const moreBtn = document.getElementById('moreBtn');
    const dropdownMenu = document.getElementById('dropdownMenu');
    moreBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        dropdownMenu.classList.toggle('show');
        console.log('üîÑ [DEBUG] Dropdown toggled:', dropdownMenu.classList.contains('show'));
    });
    document.addEventListener('click', (e) => {
        if (!moreBtn.contains(e.target) && !dropdownMenu.contains(e.target)) {
            dropdownMenu.classList.remove('show');
            console.log('üîÑ [DEBUG] Dropdown closed');
        }
    });
    document.getElementById('dropdownLogout').addEventListener('click', async () => {
        dropdownMenu.classList.remove('show');
        await handleLogout();
    });
    document.getElementById('dropdownPayment').addEventListener('click', () => {
        dropdownMenu.classList.remove('show');
        window.location.href = '/payment.html';
    });

    setupCustomInput();
    updateStyleProgress();
    document.getElementById('refreshBtn').addEventListener('click', () => loadTweets(true));
    checkServerStatus().then(() => {
        loadTweets();
        fetchUserStats();
    });
    setInterval(() => loadTweets(), 60000);
});

    async function sendUserStyle(style) {
        if (!checkAuth()) return;
        const customInput = document.getElementById('customInput');
        if (!style) {
            showNotification('Please enter a style.');
            return;
        }

        try {
            customInput.disabled = true;
            customInput.classList.add('loading-pulse');

            const response = await fetch(`${BASE_URL}/api/learn-style`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${localStorage.getItem('idToken')}`
                },
                body: JSON.stringify({ styleText: style }),
                signal: AbortSignal.timeout(5000)
            });

            if (response.status === 401) {
                window.location.href = '/auth.html';
                return;
            }

            const result = await response.json();
            if (!response.ok) throw new Error(result.error || `Network error: ${response.status}`);

            if (result.success) {
                styleProgress = result.data.styleProgress;
                updateStyleProgress();
                customInput.value = '';
                customInput.placeholder = '‚úÖ Style sent!';
                setTimeout(() => customInput.placeholder = 'Enter #feedback or your style...', 5000);
                showNotification('Style sent successfully!', 'success');
            } else {
                throw new Error(result.error || 'Unknown error');
            }
        } catch (error) {
            console.error('Style sending error:', error);
            showNotification(`Error: ${error.message}.`);
        } finally {
            customInput.disabled = false;
            customInput.classList.remove('loading-pulse');
        }
    }





    window.addEventListener('load', () => {
        refreshIdToken();
        setInterval(refreshIdToken, 1800000);
    });


</script>
</body>
</html>
