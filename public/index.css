@font-face {
    font-family: 'allright';
    src: url('./allright.ttf');
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}
.status-publishing {
    background-color: #ff9500 !important;
    animation: pulse 1.5s infinite;
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
}



::-webkit-scrollbar {
    width: 8px;
}

::-webkit-scrollbar-track {
    background: transparent;
}

::-webkit-scrollbar-thumb {
    background: linear-gradient(180deg, #ccc, #aaa);
    border-radius: 2px;
}

::-webkit-scrollbar-thumb:hover {
    background: linear-gradient(180deg, #bbb, #999);
}

body {
    background: #000;
    color: #fceded;
    font-family: 'Roboto', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    min-height: 100vh;
    overflow-y: auto;
}

.app-wrapper {
    display: flex;
    height: 100vh;
}

.container {
    max-width: none;
    height: 100vh;
    position: relative;
    padding-bottom: 100px;
}

.textt {
    background: linear-gradient(45deg, red, orange);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
}

.sidebar {
    width: 250px;
    background: #000;
    color: #ffffff;
    padding: 20px;
    position: fixed;
    height: 100vh;
    left: 0;
    top: 0;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    z-index: 10;
}

#logob {
    display: flex;
    gap: 12px;
    align-items: center;
    margin-bottom: 20px;
}

#logob img {
    height: 30px;
    width: 30px;
    border-radius: 6px;
}

.sidebar h1 {
    font-size: 24px;
    font-weight: 600;
    font-family: 'allright';
    background: linear-gradient(135deg, #ffffff, #e9ecef);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    text-align: center;
}

.sidebar-nav {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.sidebar-nav p {
    font-size: 0.6em;
    color: grey;
    margin-left: 50px;
}

.nav-item {
    color: #ffffff;
    text-decoration: none;
    padding: 10px 15px;
    border-radius: 6px;
    transition: all 0.2s;
    font-size: 12px;
}

.nav-item:hover {
    background: linear-gradient(90deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
    background-size: 100% 100%;
    transform: translateX(8px);
}

.nav-item.active {
    background: linear-gradient(90deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.08));
    background-size: 100% 100%;
    font-weight: 600;
    border-left: 3px solid #FFE06E;
}

.user-profile {
    margin-top: auto;
    border-radius: 6px;
    padding: 4px 8px;
    color: #ffffff;
    position: relative; /* Ensure dropdown positions relative to this */
}
.user-profile p {
    margin-bottom: 5px;
    color: grey;
}

.profile-section {
    display: flex;
    align-items: center;
    gap: 12px;
}

.profile-info {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    padding-inline: 10px;
}

.user-profile img {
    width: 40px;
    height: 40px;
    border-radius: 8px;
    object-fit: cover;
}

.profile-info .username {
    font-size: 14px;
    font-weight: 600;
    color: #ffffff;
    line-height: 1.2;
}

.profile-info .handle {
    font-size: 8px;
    color: #adb5bd;
    line-height: 1.2;
}

.more-btn {
    background: transparent;
    border: none;
    cursor: pointer;
    font-size: 20px;
    padding: 0;
    margin-left: auto;
    color: #ffffff;
    transition: color 0.2s ease;
    transform: rotate(90deg);
}
.dropdown-menu {
    display: none;
    position: absolute;
    bottom: calc(100% + 5px); /* Add slight offset to avoid overlap */
    left: 0;
    z-index: 1000;
    min-width: 12rem;
    background: #212529;
    border: 1px solid #495057;
    border-radius: 8px;
    padding: 6px;
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
    font-family: 'Inter', 'Segoe UI', sans-serif;
    opacity: 0;
    transform: translateY(-8px);
    transition: opacity 0.25s ease, transform 0.25s ease;
}

.dropdown-menu.show {
    display: block;
    opacity: 1;
    transform: translateY(0);
    z-index: 1001; /* Ensure it's above other elements */
}

.dropdown-menu .px-3 {
    padding: 10px 14px;
    font-size: 13px;
    color: #ffffff;
    border-bottom: 1px solid #495057;
    font-weight: 500;
}

.dropdown-menu .px-3 span {
    display: block;
}

.dropdown-menu .px-3 .font-normal {
    color: #adb5bd;
    font-weight: 400;
    font-size: 12px;
}

.dropdown-menu a, .dropdown-menu div[role="menuitem"] {
    display: flex;
    align-items: center;
    padding: 9px 14px;
    font-size: 13px;
    color: #ffffff;
    text-decoration: none;
    border-radius: 6px;
    transition: all 0.2s ease;
    cursor: pointer;
}

.dropdown-menu a:hover, .dropdown-menu div[role="menuitem"]:hover {
    background: #495057;
    color: #ffffff;
    transform: translateX(2px);
}

.dropdown-menu svg {
    margin-right: 10px;
    width: 16px;
    height: 16px;
    transition: color 0.2s ease;
}

.dropdown-menu [role="separator"] {
    margin: 6px 0;
    height: 1px;
    background: #495057;
}

.main-content {
    margin-left: 260px;
    padding: 20px;
    border-radius: 12px;
    margin-top: 10px;
    margin-bottom: 10px;

    flex: 1;
    overflow-y: auto;
    background: linear-gradient(145deg, #ffffff, #f8f9fa);
    margin-right: 20px;
    box-shadow: 0 4px 12px rgba(33, 37, 41, 0.1);
    min-height: 96vh;
}

.sticker {
    position: absolute;
    top: 10px;
    left: 260px;
    width: 105px;
    height: 105px;
    z-index: -10;
    animation: floatY 3s ease-in-out infinite;
    pointer-events: none;
    transform: rotate(-35deg);
    border: none;
    box-shadow: none;
    background: none;
    border-radius: 0;
    object-fit: contain;
}

@keyframes floatY {
    0%, 100% { transform: translateY(0) rotate(-35deg); }
    50% { transform: translateY(-5px) rotate(-35deg); }
}

.page-header {
    text-align: left;
    margin-bottom: 0; /* Minimal pour progress bar juste en dessous */
    padding: 20px 0 10px 0; /* Padding réduit */
    display: flex;
    align-items: center;
    gap: 12px;
}

.header-content {
    display: flex;
    flex-direction: row;
    align-items: center;
    gap: 6px;
}

.header-title {
    display: flex;
    flex-direction: column;
    align-items: left;
}

.header-title h3 {
    font-size: 12px;
    font-weight: 700;
    color: #212529;
    margin: 0;
    text-align: left;
}

.header-title p {
    text-align: left;
    font-size: 0.8em;
    margin: 0;
}

.twitter-logo {
    color: #1da1f2;
    width: 32px;
    height: 32px;
}

.header-description {
    color: #6c757d;
    font-size: 12px;
    max-width: 500px;
    line-height: 1.5;
}

/* Progress bar juste sous header, minimal */
.style-progress {
    width: 80%;
    height: 6px;
    background: #e9ecef;
    border-radius: 3px;
    margin: 8px 0 20px 0; /* Margin minimal */
    position: relative;
    overflow: hidden;
}

.style-progress-bar {
    height: 100%;
    background: linear-gradient(90deg, #2974ff, #00d4ff);
    transition: width 0.3s ease;
    border-radius: 3px;
}

.style-progress-text {
    font-size: 12px; /* Slightly larger for readability */
    color: #212529; /* Darker color for better contrast on light background */
    text-align: left; /* Align with progress bar */
    margin-top: 4px;
    position: relative;
    z-index: 1; /* Ensure it's above other elements */
    border: none; /* Remove debug border */
}

/* Contenu par tab (caché par défaut) */
.tab-content {
    display: none;
}

.tab-content.active {
    display: block;
}

/* Filtres sans "All" */
.filter-selector {
    display: flex;
    flex-wrap: nowrap;
    overflow-x: auto;
    gap: 8px;
    margin-bottom: 15px;
    justify-content: flex-start;
    align-items: center;
    padding-bottom: 5px;
    margin-top: 1%;
    width: 100%;
    -ms-overflow-style: none;
    scrollbar-width: none;
    border-bottom: 1px solid rgba(187, 187, 187, 0.774);
}

.filter-selector::-webkit-scrollbar {
    display: none;
}

.filter-tag {
    background: transparent;
    color: black;
    border-radius: 6px;
    padding-inline: 8px;
    font-size: 10px;
    cursor: pointer;
    transition: all 0.2s;
    user-select: none;
    text-align: center;
    display: flex;
    align-items: center;
    justify-content: center;
    min-width: 80px;
    height: 26px;
    white-space: nowrap;
}

.filter-tag:hover {
    border-color: #ced4da;
    transform: translateY(-1px);
}

.filter-tag.selected {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(33, 37, 41, 0.2);
    padding: 5px 10px;
}

.clear-filter {
    background: transparent;
    color: #6c757d;
    border: 1px dashed #ced4da;
    border-radius: 4px;
    padding: 6px 12px;
    font-size: 12px;
    cursor: pointer;
    transition: all 0.2s;
    text-align: center;
    display: none;
    min-width: 80px;
    height: 32px;
    align-items: center;
    justify-content: center;
}

.clear-filter.show {
    display: flex;
    opacity: 1;
}

.clear-filter:hover {
    color: #212529;
    border-color: #adb5bd;
}

.input-container {
    display: flex;
    flex-direction: row-reverse;
    gap: 10px;
    bottom: 10px;
    position: absolute;
    align-items: center;
    margin-bottom: 20px;
    position: relative;
    z-index: 12;
}

.circle-btn {
    min-width: 36px;
    min-height: 36px;
    background: white;
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    border: 3px solid #0d6efd;
    font-size: 18px;
}

.circle-btn:hover {
    background: #f8f9fa;
    transform: scale(1.05);
}

.circle-btn.active {
    width: 400px;
    border-radius: 6px;
    background: #ffffff;
    border-color: #0d6efd;
}

.circle-btn.active .icon {
    display: none;
}

.input-wrapper {
    display: none;
    width: 99%;
    position: absolute;
    bottom: 0;
    height: 32px;
}

.circle-btn.active .input-wrapper {
    display: flex;
    align-items: center;
}

.custom-input {
    width: 99%;
    background: #f8f9fa;
    color: #212529;
    border: 1px solid #dee2e6;
    border-radius: 4px;
    padding: 12px 16px;
    font-size: 10px;
    outline: none;
    transition: all 0.2s;
    height: 30px;
}

.custom-input:focus {
    border-color: #86b6fe00;
    background: #ffffff;
}

.custom-input::placeholder {
    color: #adb5bd;
}

@keyframes loadingPulse {
    0% { box-shadow: 0 0 0 0 rgba(13, 110, 253, 0.7); transform: scale(1); }
    50% { box-shadow: 0 0 0 8px rgba(13, 110, 253, 0.2); transform: scale(1.05); }
    100% { box-shadow: 0 0 0 0 rgba(13, 110, 253, 0); transform: scale(1); }
}

.loading-pulse {
    animation: loadingPulse 1.5s ease-in-out infinite;
    border-color: blue;
}

.refresh-btn, .logout-btn, .payment-btn {
    background: #212529;
    color: #ffffff;
    border: none;
    border-radius: 6px;
    padding: 10px 28px;
    font-size: 10px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s;
    display: block;
    box-shadow: 0 4px 12px rgba(33, 37, 41, 0.2);
}

.refresh-btn:hover, .logout-btn:hover, .payment-btn:hover {
    background: #495057;
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(33, 37, 41, 0.3);
}

.refresh-btn:disabled, .logout-btn:disabled, .payment-btn:disabled {
    background: #e9ecef;
    color: #adb5bd;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}

.refresh-btn {
    margin-bottom: 1%;
}

.tweets-grid, .tweets-grid.filtered {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(330px, 1fr));
    gap: 10px;
    width: 100%;
}

.tweet-item {
    background: linear-gradient(145deg, #ffffff, #f8f9fa);
    border: 1px solid #dee2e6;
    border-radius: 8px;
    padding: 10px;
    transition: all 0.3s;
    position: relative;
    min-height: 180px;
    display: flex;
    flex-direction: column;
}

.tweet-item:hover {
    background: linear-gradient(145deg, #f8f9fa, #e9ecef);
    border-color: #ced4da;
    transform: translateY(-2px);
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
}

.mode-badge {
    background: linear-gradient(45deg, #e9ecef, #dee2e6);
    color: #495057;
    padding: 4px 12px;
    border-radius: 4px;
    font-size: 8px;
    text-transform: uppercase;
    font-weight: 600;
    font-family: 'Lato', sans-serif;
}

.badge-timestamp {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 8px;
}

.tweet-post {
    display: flex;
    gap: 12px;
    margin-bottom: 12px;
    font-size: 11px;
    line-height: 1.4;
    background: rgba(0, 0, 0, 0.02);
    padding: 12px;
    border-radius: 6px;
    flex: 1;
    cursor: pointer;
    transition: all 0.2s;
}

.tweet-post:hover {
    background: rgba(0, 0, 0, 0.04);
}

.tweet-post img {
    width: 32px;
    height: 32px;
    border-radius: 8px;
    object-fit: cover;
    flex-shrink: 0;
}

.tweet-post-content {
    flex: 1;
    color: #212529;
    font-family: 'Roboto', sans-serif;
    word-break: break-word;
}

.tweet-post-content a {
    color: #0d6efd;
    text-decoration: none;
}

.tweet-post-content a:hover {
    text-decoration: underline;
}

.tweet-content {
    background: rgba(0, 0, 0, 0.02);
    border: 1px solid #dee2e6;
    color: #212529;
    font-family: 'Roboto', sans-serif;
    font-size: 11px;
    line-height: 1.4;
    width: 100%;
    min-height: 80px;
    resize: vertical;
    outline: none;
    margin-bottom: 12px;
    padding: 12px;
    border-radius: 6px;
    display: none;
    flex: 1;
}

.tweet-content:focus {
    background: rgba(0, 0, 0, 0.04);
    border-color: #0d6efd;
}

.timestamp {
    color: #adb5bd;
    font-size: 10px;
    font-family: 'Lato', sans-serif;
}

.tweet-meta {
    color: #6c757d;
    font-size: 10px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: auto;
    padding-top: 6px;
    border-top: 1px solid #dee2e6;
}

.button-group {
    display: flex;
    gap: 8px;
}

.copy-btn, .regen-btn, .delete-btn, .schedule-btn, .media-btn {
    background: transparent;
    color: #212529;
    border: none;
    border-radius: 4px;
    padding: 6px;
    cursor: pointer;
    transition: all 0.2s;
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.copy-btn:hover { background: rgba(25, 135, 84, 0.2); transform: translateY(-1px); }
.regen-btn:hover { background: rgba(13, 110, 253, 0.2); transform: translateY(-1px); }
.delete-btn:hover { background: rgba(220, 53, 69, 0.2); transform: translateY(-1px); }
.schedule-btn:hover { background: rgba(33, 150, 243, 0.2); transform: translateY(-1px); }
.media-btn:hover { background: rgba(156, 39, 176, 0.2); transform: translateY(-1px); }

.copy-btn.copied { background: rgba(25, 135, 84, 0.3); }
.regen-btn.regenerated { background: rgba(13, 110, 253, 0.3); }
.schedule-btn.scheduled { background: rgba(33, 150, 243, 0.3); }
.media-btn.uploaded { background: rgba(156, 39, 176, 0.3); }

.no-tweets {
    text-align: center;
    padding: 60px 20px;
    color: #6c757d;
    font-size: 14px;
    line-height: 1.6;
    font-family: 'Lato', sans-serif;
}

.notification {
    position: fixed;
    top: 10px;
    right: 10px;
    background: #ffffff;
    padding: 8px 12px;
    border-radius: 4px;
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
    transform: translateY(-100%);
    transition: transform 0.3s;
    z-index: 1000;
    color: #212529;
    font-size: 11px;
    font-family: 'Lato', sans-serif;
    border: 1px solid #dee2e6;
}

.notification.show {
    transform: translateY(0);
}

.notification.success { border-left: 3px solid #198754; }
.notification.error { border-left: 3px solid #dc3545; }

#onboarding-popup {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 450px;
    background: #ffffff;
    border: 1px solid #dee2e6;
    border-radius: 8px;
    padding: 24px;
    z-index: 1000;
    display: none;
    box-shadow: 0 16px 64px rgba(0, 0, 0, 0.1);
}

#onboarding-popup h2 {
    color: #212529;
    font-size: 18px;
    margin-bottom: 16px;
}

#onboarding-form .question-step {
    display: none;
    flex-direction: column;
    gap: 8px;
}

#onboarding-form .question-step.active {
    display: flex;
}

#onboarding-form label {
    font-weight: 600;
    color: #212529;
}

#onboarding-form input {
    background: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 6px;
    padding: 10px;
    font-size: 14px;
}

.popup-buttons {
    display: flex;
    justify-content: space-between;
    margin-top: 16px;
}

#skip-onboarding, #next-step, #submit-onboarding {
    background: #212529;
    color: #ffffff;
    border: none;
    padding: 10px 20px;
    border-radius: 6px;
    cursor: pointer;
}

#skip-onboarding {
    background: transparent;
    color: #6c757d;
    border: 1px solid #dee2e6;
}

.schedule-dialog {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: linear-gradient(145deg, #ffffff, #f8f9fa);
    border: 1px solid #dee2e6;
    border-radius: 16px;
    padding: 24px;
    z-index: 1000;
    display: none;
    flex-direction: column;
    gap: 16px;
    min-width: 300px;
    box-shadow: 0 16px 64px rgba(0, 0, 0, 0.1);
}

.schedule-dialog h3 {
    color: #212529;
    margin-bottom: 8px;
    font-size: 16px;
    font-weight: 600;
}

.datetime-group {
    display: flex;
    flex-direction: column;
}

.datetime-group label {
    font-weight: 600;
    margin-bottom: 8px;
    color: #212529;
}

.datetime-input {
    background: #f8f9fa;
    color: #212529;
    border: 1px solid #dee2e6;
    border-radius: 8px;
    padding: 12px;
    font-size: 14px;
    transition: border-color 0.3s;
}

.datetime-input:focus {
    border-color: #ced4da;
    outline: none;
}

.schedule-dialog .button-group {
    display: flex;
    gap: 12px;
    justify-content: flex-end;
}

.schedule-dialog button {
    background: #212529;
    color: #ffffff;
    border: none;
    border-radius: 8px;
    padding: 10px 16px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 600;
    transition: all 0.2s;
}

.schedule-dialog button:hover {
    background: #495057;
    transform: translateY(-1px);
}

.schedule-dialog button.cancel {
    background: transparent;
    color: #6c757d;
    border: 1px solid #dee2e6;
}

.schedule-dialog button.cancel:hover {
    background: #f8f9fa;
    color: #212529;
    border-color: #ced4da;
}

.status-indicator {
    display: inline-block;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    margin-right: 4px;
}

.status-scheduled { background: #ffad1f; }
.status-published { background: #198754; }
.status-failed { background: #dc3545; }

.media-upload-container {
    margin-top: 10px;
}

.media-upload {
    border: 2px dashed #dee2e6;
    border-radius: 8px;
    padding: 10px;
    text-align: center;
    cursor: pointer;
    transition: all 0.3s;
    font-size: 12px;
    color: #6c757d;
}

.media-upload:hover {
    border-color: #ced4da;
    background: #f8f9fa;
}

.media-upload input {
    display: none;
}

.media-preview {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
    gap: 8px;
    margin-top: 10px;
}

.media-item {
    position: relative;
    border-radius: 4px;
    overflow: hidden;
}

.media-item img {
    width: 100%;
    height: 80px;
    object-fit: cover;
    display: block;
}

.media-item video {
    width: 100%;
    height: 80px;
    object-fit: cover;
    display: block;
}

.media-remove {
    position: absolute;
    top: 4px;
    right: 4px;
    background: rgba(0, 0, 0, 0.1);
    color: #212529;
    border: none;
    border-radius: 50%;
    width: 20px;
    height: 20px;
    cursor: pointer;
    font-size: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background 0.2s;
}

.media-remove:hover {
    background: rgba(220, 53, 69, 0.7);
}

.media-remove:disabled {
    background: rgba(0, 0, 0, 0.05);
    cursor: not-allowed;
}

svg {
    margin-right: 5px;
}

.subtitle {
    color: #adb5bd;
    font-size: 12px;
    text-align: center;
    margin-bottom: 20px;
    font-style: italic;
}

.coming-soon {
    font-size: 10px;
    color: #6c757d;
    margin-left: auto;
}

/* Coming soon en bas du main-content */
.coming-soon-footer {
    text-align: center;
    padding: 20px;
    color: #6c757d;
    font-size: 14px;
    font-style: italic;
    border-top: 1px solid #dee2e6;
    margin-top: auto;
}

@media (max-width: 900px) {
    .tweets-grid, .tweets-grid.filtered { grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 16px; }
    .sidebar { width: 200px; }
    .main-content { margin-left: 210px; }
}

@media (max-width: 600px) {
    .tweets-grid, .tweets-grid.filtered { grid-template-columns: 1fr; gap: 12px; }
    .tweet-item { padding: 16px; min-height: 180px; }
    .tweet-meta { flex-direction: column; align-items: flex-start; gap: 2px; max-height: 15px; }
    .circle-btn.active { width: 100%; }
    .filter-selector { gap: 4px; }
    .filter-tag { font-size: 10px; padding: 4px 8px; min-width: 60px; height: 28px; }
    .clear-filter { font-size: 10px; padding: 4px 8px; min-width: 60px; height: 28px; }
    .sidebar { width: 150px; }
    .main-content { margin-left: 160px; }
    .sidebar h1 { font-size: 20px; }
    .nav-item { font-size: 12px; padding: 8px 10px; }
}
.input-container {
    position: fixed;
    bottom: 1px;
    left: 280px;
    z-index: 1000;

    border-radius: 16px;
    padding: 16px;
    display: flex;
    flex-direction: column;
    gap: 10px;
}
.tab-content {
    animation: slideIn 0.3s ease-out;
}

@keyframes slideIn {
    from { opacity: 0; transform: translateX(20px); }
    to { opacity: 1; transform: translateX(0); }
}


/*

 // Add event listeners for media inputs
        document.querySelectorAll('.media-upload input').forEach(input => {
            input.addEventListener('change', (e) => {
                const tweetId = e.target.id.replace('media-input-', '');
                const [_, tweetGroupId, tweetIndex] = tweetId.split('_');
                const scheduleKey = `${tweetGroupId}_${tweetIndex}`;
                let mediaList = selectedMedia.get(scheduleKey) || [];
                if (mediaList.length >= 4) {
                    showNotification('Maximum 4 media per tweet.');
                    return;
                }
                const newFiles = Array.from(e.target.files);
                if (mediaList.length + newFiles.length > 4) {
                    showNotification(`Maximum 4 media. ${4 - mediaList.length} file(s) remaining.`);
                    return;
                }
                newFiles.forEach(file => {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const mediaItem = {
                            id: Date.now() + Math.random(),
                            file,
                            url: e.target.result,
                            type: file.type.startsWith('image/') ? 'image' : 'video',
                            mimetype: file.type
                        };
                        mediaList.push(mediaItem);
                        selectedMedia.set(scheduleKey, mediaList);
                        renderMediaPreview(tweetId, scheduleKey);
                    };
                    reader.readAsDataURL(file);
                });
                e.target.value = '';
            });
        });

        // Render media previews
        document.querySelectorAll('.media-preview').forEach(preview => {
            const tweetId = preview.id.replace('media-preview-', '');
            const scheduleKey = tweetId.replace('tweet_', '');
            renderMediaPreview(tweetId, scheduleKey);
        });
    }

    function toggleMediaUpload(tweetId) {
        const mediaContainer = document.getElementById(`media-upload-${tweetId}`);
        mediaContainer.style.display = mediaContainer.style.display === 'block' ? 'none' : 'block';
        if (mediaContainer.style.display === 'block') {
            const scheduleKey = tweetId.replace('tweet_', '');
            renderMediaPreview(tweetId, scheduleKey);
        }
    }

    function renderMediaPreview(tweetId, scheduleKey) {
        const mediaPreview = document.getElementById(`media-preview-${tweetId}`);
        if (!mediaPreview) return;

        const clientMedia = selectedMedia.get(scheduleKey) || [];
        const serverMedia = scheduledTweets.find(t => `${t.tweetId}_${t.tweetIndex}` === scheduleKey)?.media || [];
        const mergedMedia = [
            ...serverMedia.filter(m => m && m.filename && m.mimetype).map(m => ({
                id: m.id || (m.filename + Math.random()),
                url: m.url || `${BASE_URL}/uploads/${m.filename}`,
                type: m.type || (m.mimetype && m.mimetype.startsWith('image/') ? 'image' : 'video'),
                server: true,
                mimetype: m.mimetype
            })),
            ...clientMedia.filter(m => !m.server)
        ].slice(0, 4);

        mediaPreview.innerHTML = mergedMedia.map(media => `
            <div class="media-item" data-media-id="${media.id}">
                ${media.type === 'image'
                    ? `<img src="${media.url}" alt="Preview">`
                    : `<video src="${media.url}" controls style="width: 100%; height: 80px;"></video>`
                }
                ${!media.server ? `<button class="media-remove" data-schedule-key="${scheduleKey}" data-media-id="${media.id}">×</button>` : ''}
            </div>
        `).join('');

        mediaPreview.querySelectorAll('.media-remove').forEach(button => {
            button.addEventListener('click', () => {
                const scheduleKey = button.dataset.scheduleKey;
                const mediaId = parseFloat(button.dataset.mediaId);
                removeMedia(scheduleKey, mediaId, button);
            });
        });
    }

    function removeMedia(scheduleKey, mediaId, button) {
        button.disabled = true;
        button.style.background = 'rgba(0,0,0,0.05)';
        let mediaList = selectedMedia.get(scheduleKey) || [];
        const originalLength = mediaList.length;
        mediaList = mediaList.filter(media => media.id !== mediaId);
        if (mediaList.length < originalLength) {
            selectedMedia.set(scheduleKey, mediaList);
            const tweetId = `tweet_${scheduleKey}`;
            renderMediaPreview(tweetId, scheduleKey);
            showNotification('Media removed.');
        } else {
            showNotification('Error removing media.', 'error');
        }
        button.disabled = false;
        button.style.background = 'rgba(0,0,0,0.1)';
    }

    function toggleEdit(tweetId) {
        const textarea = document.getElementById(tweetId);
        const tweetPost = textarea.closest('.tweet-item').querySelector('.tweet-post');

        if (textarea.style.display === 'none' || !textarea.style.display) {
            textarea.style.display = 'block';
            tweetPost.style.display = 'none';
            textarea.focus();
            textarea.setSelectionRange(textarea.value.length, textarea.value.length);
        } else {
            textarea.style.display = 'none';
            tweetPost.style.display = 'flex';

            const [_, tweetGroupId, tweetIndex] = tweetId.split('_');
            if (textarea.dataset.dirty === 'true') {
                saveTweetEdit(tweetGroupId, parseInt(tweetIndex), textarea.value.trim());
            }
        }
    }

    async function deleteTweet(tweetId, tweetIndex) {
        if (!checkAuth()) return;
        if (!confirm('Do you really want to delete this tweet?')) return;

        const tweetElement = document.getElementById(`tweet_${tweetId}_${tweetIndex}_container`);
        const deleteBtn = tweetElement.querySelector('.delete-btn');
        const originalContent = deleteBtn.innerHTML;

        deleteBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle></svg>';
        deleteBtn.disabled = true;

        const scheduleKey = `${tweetId}_${tweetIndex}`;
        const tweetInfo = scheduledTweets.find(t => `${t.tweetId}_${t.tweetIndex}` === scheduleKey);

        const maxRetries = 3;
        let retryCount = 0;

        async function attemptDelete() {
            try {
                if (tweetInfo) {
                    const response = await fetchWithRetry(`${BASE_URL}/api/tweets/${tweetInfo.id}`, {
                        method: 'DELETE',
                        headers: {
                            'Authorization': `Bearer ${localStorage.getItem('idToken')}`
                        },
                        signal: AbortSignal.timeout(5000)
                    });
                    if (!response.ok) {
                        const result = await response.json();
                        throw new Error(result.error || `Network error: ${response.status}`);
                    }
                    scheduledTweets = scheduledTweets.filter(t => `${t.tweetId}_${t.tweetIndex}` !== scheduleKey);
                    tweetSchedules.delete(scheduleKey);
                    selectedMedia.delete(scheduleKey);
                }

                const response = await fetch(`${BASE_URL}/api/delete-tweet`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('idToken')}`
                    },
                    body: JSON.stringify({ tweetId, tweetIndex }),
                    signal: AbortSignal.timeout(5000)
                });

                if (response.status === 401) {
                    window.location.href = '/auth.html';
                    return;
                }

                const result = await response.json();
                if (!response.ok) {
                    throw new Error(result.error || `Network error: ${response.status}`);
                }

                if (result.success) {
                    tweetElement.remove();
                    const group = tweetsDataCache.find(g => g.id === tweetId);
                    if (group) {
                        group.generatedTweets.splice(tweetIndex, 1);
                        if (group.modesUsed) group.modesUsed.splice(tweetIndex, 1);
                        group.lastModified = result.data?.lastModified;
                        if (group.generatedTweets.length === 0) {
                            tweetsDataCache = tweetsDataCache.filter(g => g.id !== tweetId);
                        }
                    }
                    displayTweets(tweetsDataCache);
                    showNotification('Tweet deleted successfully!', 'success');
                    if (!document.querySelector('.tweet-item')) {
                        document.getElementById('tweets-container').innerHTML = '<div class="no-tweets">No tweets generated</div>';
                    }
                } else {
                    throw new Error(result.error || 'Unknown error');
                }
            } catch (error) {
                if (retryCount < maxRetries) {
                    retryCount++;
                    console.log(`Attempt ${retryCount}/${maxRetries} failed for deletion, retrying...`);
                    await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
                    return attemptDelete();
                }
                throw error;
            }
        }

        try {
            await attemptDelete();
        } catch (error) {
            console.error('Tweet deletion error:', error);
            showNotification(`Error: ${error.message}.`);
            deleteBtn.innerHTML = originalContent;
            deleteBtn.disabled = false;
        }
    }

    function updateCharCount(event) {
        const textarea = event.target;
        const countElement = document.getElementById(`count_${textarea.id}`);
        if (countElement) {
            const length = textarea.value.length;
            countElement.textContent = `${length}/280`;
            countElement.style.color = length > 280 ? '#dc3545' : length > 250 ? '#ffc107' : '#6c757d';
            textarea.dataset.dirty = 'true';

            // Update tweet display
            const tweetElement = textarea.closest('.tweet-item');
            const postContent = tweetElement.querySelector('.tweet-post-content');
            postContent.innerHTML = formatTweetText(textarea.value);
        }
    }

    async function saveTweetEdit(tweetId, tweetIndex, newText) {
        if (!checkAuth()) return;
        if (!newText) {
            showNotification('Tweet cannot be empty.');
            return;
        }
        if (newText.length > 280) {
            showNotification('Tweet exceeds 280 characters.');
            return;
        }

        const textarea = document.getElementById(`tweet_${tweetId}_${tweetIndex}`);
        const maxRetries = 3;
        let retryCount = 0;

        async function attemptSave() {
            try {
                textarea.disabled = true;
                textarea.classList.add('loading-pulse');

                const response = await fetch(`${BASE_URL}/api/edit-tweet`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('idToken')}`
                    },
                    body: JSON.stringify({ tweetId, tweetIndex, newText }),
                    signal: AbortSignal.timeout(5000)
                });

                if (response.status === 401) {
                    window.location.href = '/auth.html';
                    return;
                }

                const result = await response.json();
                if (!response.ok) throw new Error(result.error || `Network error: ${response.status}`);

                if (result.success) {
                    textarea.dataset.dirty = 'false';
                    updateCharCount({ target: textarea });
                    styleProgress = result.data.styleProgress || styleProgress;
                    updateStyleProgress();
                    showNotification('Tweet modified successfully!', 'success');

                    const group = tweetsDataCache.find(g => g.id === tweetId);
                    if (group) {
                        group.generatedTweets[tweetIndex] = newText;
                        group.lastModified = result.data?.lastModified;
                    }
                    const scheduleKey = `${tweetId}_${tweetIndex}`;
                    const tweetInfo = scheduledTweets.find(t => `${t.tweetId}_${t.tweetIndex}` === scheduleKey);
                    if (tweetInfo) {
                        tweetInfo.content = newText;
                    }
                    displayTweets(tweetsDataCache);
                } else {
                    throw new Error(result.error || 'Unknown error');
                }
            } catch (error) {
                if (retryCount < maxRetries) {
                    retryCount++;
                    console.log(`Attempt ${retryCount}/${maxRetries} failed for save, retrying...`);
                    await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
                    return attemptSave();
                }
                throw error;
            }
        }

        try {
            await attemptSave();
        } catch (error) {
            console.error('Tweet modification error:', error);
            showNotification(`Error: ${error.message}.`);
        } finally {
            textarea.disabled = false;
            textarea.classList.remove('loading-pulse');
        }
    }

    async function copyTweet(tweetId) {
        const textarea = document.getElementById(tweetId);
        const tweetElement = textarea.closest('.tweet-item');
        const copyBtn = tweetElement.querySelector('.copy-btn');
        const originalContent = copyBtn.innerHTML;

        try {
            await navigator.clipboard.writeText(textarea.value);
            copyBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20,6 9,17 4,12"></polyline></svg>';
            copyBtn.classList.add('copied');
            tweetElement.style.background = 'linear-gradient(145deg, #f8f9fa, #e9ecef)';
            tweetElement.style.borderColor = '#ced4da';
            showNotification('Tweet copied!', 'success');

            setTimeout(() => {
                copyBtn.innerHTML = originalContent;
                copyBtn.classList.remove('copied');
                tweetElement.style.background = 'linear-gradient(145deg, #ffffff, #f8f9fa)';
                tweetElement.style.borderColor = '#dee2e6';
            }, 2000);
        } catch (error) {
            console.error('Copy error:', error);
            showNotification('Copy error.', 'error');
            copyBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>';
            setTimeout(() => copyBtn.innerHTML = originalContent, 2000);
        }
    }

    async function regenerateTweet(tweetId, tweetIndex, mode) {
        if (!checkAuth()) return;

        const tweetElement = document.getElementById(`tweet_${tweetId}_${tweetIndex}_container`);
        const regenBtn = tweetElement.querySelector('.regen-btn');
        const originalContent = regenBtn.innerHTML;

        regenBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle></svg>';
        regenBtn.disabled = true;

        const maxRetries = 3;
        let retryCount = 0;

        async function attemptRegenerate() {
            try {
                const response = await fetch(`${BASE_URL}/api/regenerate-tweet`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('idToken')}`
                    },
                    body: JSON.stringify({ tweetId, tweetIndex, mode }),
                    signal: AbortSignal.timeout(5000)
                });

                if (response.status === 401) {
                    window.location.href = '/auth.html';
                    return;
                }

                const result = await response.json();
                if (!response.ok) throw new Error(result.error || 'Network error');

                if (result.success && result.data) {
                    const textarea = document.getElementById(`tweet_${tweetId}_${tweetIndex}`);
                    textarea.value = result.data.tweet;
                    textarea.dataset.dirty = 'false';
                    updateCharCount({ target: textarea });

                    regenBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20,6 9,17 4,12"></polyline></svg>';
                    regenBtn.classList.add('regenerated');

                    setTimeout(() => {
                        regenBtn.innerHTML = originalContent;
                        regenBtn.classList.remove('regenerated');
                        regenBtn.disabled = false;
                    }, 2000);

                    showNotification('Tweet regenerated successfully!', 'success');

                    const group = tweetsDataCache.find(g => g.id === tweetId);
                    if (group) {
                        group.generatedTweets[tweetIndex] = result.data.tweet;
                        if (group.modesUsed) group.modesUsed[tweetIndex] = mode;
                        group.lastModified = result.data?.lastModified;
                    }
                    displayTweets(tweetsDataCache);
                } else {
                    throw new Error(result.error || 'Unknown error');
                }
            } catch (error) {
                if (retryCount < maxRetries) {
                    retryCount++;
                    console.log(`Attempt ${retryCount}/${maxRetries} failed for regeneration, retrying...`);
                    await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
                    return attemptRegenerate();
                }
                throw error;
            }
        }

        try {
            await attemptRegenerate();
        } catch (error) {
            console.error('Regeneration error:', error);
            showNotification(`Error: ${error.message}.`, 'error');
            regenBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>';
            setTimeout(() => {
                regenBtn.innerHTML = originalContent;
                regenBtn.disabled = false;
            }, 2000);
        }
    }

    function openScheduleDialog(tweetId, tweetIndex) {
        currentTweetId = tweetId;
        currentTweetIndex = tweetIndex;
        const dialog = document.getElementById('schedule-dialog');
        const scheduleDate = document.getElementById('scheduleDate');
        const scheduleTime = document.getElementById('scheduleTime');
        const now = new Date();
        now.setMinutes(0, 0, 0);
        scheduleDate.min = now.toISOString().split('T')[0];
        scheduleDate.value = now.toISOString().split('T')[0];
        now.setHours(now.getHours() + 1);
        scheduleTime.value = now.toTimeString().slice(0, 5);
        dialog.style.display = 'flex';
        scheduleDate.focus();
    }

    function closeScheduleDialog() {
        document.getElementById('schedule-dialog').style.display = 'none';
        currentTweetId = null;
        currentTweetIndex = null;
    }

    async function confirmSchedule() {
        console.log('🎯 [DEBUG] confirmSchedule() appelée');

        if (!currentTweetId || currentTweetIndex === null) {
            console.log('❌ [DEBUG] Aucun tweet sélectionné:', { currentTweetId, currentTweetIndex });
            showNotification('No tweet selected.', 'error');
            return;
        }

        console.log('✅ [DEBUG] Tweet sélectionné:', { currentTweetId, currentTweetIndex });

        const scheduleDate = document.getElementById('scheduleDate');
        const scheduleTime = document.getElementById('scheduleTime');
        const content = document.getElementById(`tweet_${currentTweetId}_${currentTweetIndex}`).value.trim();
        const scheduleKey = `${currentTweetId}_${currentTweetIndex}`;
        const tweetElement = document.getElementById(`tweet_${currentTweetId}_${currentTweetIndex}_container`);
        const scheduleBtn = tweetElement.querySelector('.schedule-btn');
        const originalContent = scheduleBtn.innerHTML;

        console.log('📝 [DEBUG] Contenu du tweet:', { content, length: content.length });

        // Validations basiques
        if (!content) {
            console.log('❌ [DEBUG] Tweet vide');
            showNotification('Tweet cannot be empty.', 'error');
            return;
        }
        if (content.length > 280) {
            console.log('❌ [DEBUG] Tweet trop long:', content.length);
            showNotification('Tweet exceeds 280 characters.', 'error');
            return;
        }
        if (!scheduleDate.value || !scheduleTime.value) {
            console.log('❌ [DEBUG] Date/heure manquante:', { date: scheduleDate.value, time: scheduleTime.value });
            showNotification('Please select date and time.', 'error');
            return;
        }

        const datetime = `${scheduleDate.value}T${scheduleTime.value}:00`;
        const scheduleDateTime = new Date(datetime);
        const now = new Date();

        console.log('⏰ [DEBUG] Validation date:', {
            datetime,
            scheduleDateTime: scheduleDateTime.toISOString(),
            now: now.toISOString(),
            isFuture: scheduleDateTime > now
        });

        if (scheduleDateTime <= now) {
            console.log('❌ [DEBUG] Date dans le passé');
            showNotification('Date must be in the future.', 'error');
            return;
        }

        // UI feedback de chargement
        scheduleBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle></svg>';
        scheduleBtn.disabled = true;

        const maxRetries = 3;
        let retryCount = 0;

        async function attemptSchedule() {
            console.log(`🔄 [DEBUG] Tentative de scheduling ${retryCount + 1}/${maxRetries}`);

            try {
                const formData = new FormData();
                formData.append('content', content);
                formData.append('datetime', datetime);
                formData.append('tweetId', currentTweetId);
                formData.append('tweetIndex', currentTweetIndex);

                const mediaItems = selectedMedia.get(scheduleKey) || [];
                console.log('🖼️ [DEBUG] Médias attachés:', mediaItems.length);

                mediaItems.forEach((media, index) => {
                    if (media.file && media.mimetype) {
                        console.log(`📎 [DEBUG] Média ${index}:`, { name: media.file.name, type: media.mimetype });
                        formData.append('media', media.file, media.file.name);
                    }
                });

                console.log('📡 [DEBUG] Envoi requête vers /api/schedule-tweet...');

                const response = await fetch(`${BASE_URL}/api/schedule-tweet`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('idToken')}`
                    },
                    body: formData,
                    signal: AbortSignal.timeout(15000) // Augmenté à 15s
                });

                console.log('📥 [DEBUG] Réponse reçue:', {
                    status: response.status,
                    ok: response.ok,
                    statusText: response.statusText
                });

                if (response.status === 401) {
                    console.log('🔒 [DEBUG] Token Firebase expiré, redirection auth');
                    window.location.href = '/auth.html';
                    return;
                }

                const result = await response.json();
                console.log('📋 [DEBUG] Résultat parsing:', result);

                if (!response.ok) {
                    console.log('❌ [DEBUG] Erreur serveur:', result.error);
                    throw new Error(result.error || `Network error: ${response.status}`);
                }

                if (result.success) {
                    console.log('🎉 [DEBUG] Scheduling réussi !');

                    // Mise à jour des données locales
                    tweetSchedules.set(scheduleKey, scheduleDateTime.toISOString());
                    scheduledTweets = scheduledTweets.filter(t => `${t.tweetId}_${t.tweetIndex}` !== scheduleKey);
                    scheduledTweets.push({
                        id: result.tweet.id,
                        content,
                        datetime: scheduleDateTime,
                        media: result.tweet.media || [],
                        status: 'scheduled',
                        tweetId: currentTweetId,
                        tweetIndex: currentTweetIndex,
                        lastModified: result.tweet.lastModified,
                        createdAt: new Date(result.tweet.createdAt)
                    });

                    // Mise à jour UI
                    const timestampElement = tweetElement.querySelector('.timestamp');
                    timestampElement.innerHTML = `
                        ${formatDate(new Date(result.tweet.createdAt))}
                        <span class="status-indicator status-scheduled"></span>
                        <span style="font-size: 10px; color: #888;">Scheduled on ${formatDate(scheduleDateTime)}</span>
                    `;

                    // Reset des médias
                    selectedMedia.set(scheduleKey, []);
                    renderMediaPreview(`tweet_${currentTweetId}_${currentTweetIndex}`, scheduleKey);

                    // Feedback visuel succès
                    scheduleBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20,6 9,17 4,12"></polyline></svg>';
                    scheduleBtn.classList.add('scheduled');
                    showNotification('Tweet scheduled successfully!', 'success');

                    setTimeout(() => {
                        scheduleBtn.innerHTML = originalContent;
                        scheduleBtn.classList.remove('scheduled');
                        scheduleBtn.disabled = false;
                    }, 2000);

                    closeScheduleDialog();
                    displayTweets(tweetsDataCache);

                } else {
                    console.log('❌ [DEBUG] Échec scheduling serveur:', result.error);
                    throw new Error(result.error || 'Unknown scheduling error');
                }
            } catch (error) {
                console.error(`❌ [DEBUG] Erreur tentative ${retryCount + 1}:`, error.message);

                if (retryCount < maxRetries) {
                    retryCount++;
                    console.log(`🔄 [DEBUG] Retry ${retryCount}/${maxRetries} dans ${1000 * retryCount}ms...`);
                    await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
                    return attemptSchedule();
                }
                throw error;
            }
        }

        try {
            const status = await checkTwitterStatus(); // Appel à ta fonction checkTwitterStatus
            if (!status.authenticated) {
                showNotification('Connectez Twitter pour scheduler.', 'error');
                authenticateTwitter(); // Prompt connexion
                return;
            }
            await attemptSchedule();
        } catch (error) {
            console.error('💥 [DEBUG] Échec final scheduling:', error);
            showNotification(`Error: ${error.message}`, 'error');

            // UI feedback échec
            scheduleBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>';
            setTimeout(() => {
                scheduleBtn.innerHTML = originalContent;
                scheduleBtn.disabled = false;
            }, 2000);
        }
    }

    //new
    async function sendTwitterTokensToServer(user, credential) {
        console.log('🐦 [DEBUG] sendTwitterTokensToServer() appelée');
        console.log('👤 [DEBUG] User Firebase:', { uid: user.uid, displayName: user.displayName });
        console.log('🔑 [DEBUG] Credential reçu:', !!credential);

        try {
            const idToken = await user.getIdToken();
            console.log('🎫 [DEBUG] ID Token Firebase récupéré');

            // Extraire les tokens Twitter du credential
            let twitterAccessToken = null;
            let twitterSecret = null;

            if (credential && credential.accessToken && credential.secret) {
                // OAuth 1.0a (Twitter v1)
                twitterAccessToken = credential.accessToken;
                twitterSecret = credential.secret;
                console.log('🔐 [DEBUG] Tokens Twitter OAuth 1.0a extraits');
            } else if (credential && credential.accessToken) {
                // OAuth 2.0 (Twitter v2)
                twitterAccessToken = credential.accessToken;
                console.log('🔐 [DEBUG] Token Twitter OAuth 2.0 extrait');
            } else {
                console.log('⚠️ [DEBUG] Aucun token Twitter trouvé dans credential');
            }

            const payload = {
                twitterAccessToken,
                twitterSecret,
                userInfo: {
                    uid: user.uid,
                    displayName: user.displayName,
                    email: user.email,
                    photoURL: user.photoURL
                }
            };

            console.log('📤 [DEBUG] Envoi vers /api/login:', {
                hasTwitterToken: !!twitterAccessToken,
                hasTwitterSecret: !!twitterSecret,
                uid: user.uid
            });

            const response = await fetch(`${BASE_URL}/api/login`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${idToken}`
                },
                body: JSON.stringify(payload)
            });

            console.log('📥 [DEBUG] Réponse /api/login:', {
                status: response.status,
                ok: response.ok
            });

            const result = await response.json();
            console.log('📋 [DEBUG] Résultat /api/login:', result);

            if (result.success) {
                console.log('✅ [DEBUG] Connexion serveur réussie');
                console.log('🐦 [DEBUG] Twitter connecté:', result.twitterConnected);

                // Stocker les infos localement si nécessaire
                if (result.twitterUser) {
                    console.log('👤 [DEBUG] Info Twitter user:', result.twitterUser);
                }

                return result;
            } else {
                console.error('❌ [DEBUG] Échec connexion serveur:', result.error);
                throw new Error(result.error || 'Échec connexion serveur');
            }

        } catch (error) {
            console.error('💥 [DEBUG] Erreur sendTwitterTokensToServer:', error);
            throw error;
        }
    }
    //mew


    // Fonction pour initier l'authentification Twitter
    async function authenticateTwitter() {
      try {
        console.log('🔄 Début authentification Twitter...');

        // Récupérer le token Firebase
        const token = localStorage.getItem('idToken');
        if (!token) {
          throw new Error('Utilisateur non authentifié avec Firebase');
        }

       const response = await fetch(`${BASE_URL}/api/auth/twitter`, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      }
    });

        const data = await response.json();

        if (!response.ok) {
          throw new Error(data.error || 'Erreur lors de la demande d\'authentification');
        }

        if (!data.success || !data.authUrl) {
          throw new Error('URL d\'authentification non reçue');
        }

        console.log('✅ URL d\'authentification reçue:', data.authUrl);

        // Ajouter le token Firebase à l'URL de callback
        const authUrlWithToken = `${data.authUrl}&firebase_token=${encodeURIComponent(token)}`;

        // Ouvrir la popup d'authentification Twitter
        const popup = window.open(
          data.authUrl,
          'twitter-auth',
          'width=600,height=700,scrollbars=yes,resizable=yes'
        );

        // Écouter la fermeture de la popup
        const checkClosed = setInterval(() => {
          if (popup.closed) {
            clearInterval(checkClosed);
            console.log('🔄 Popup fermée, vérification du statut...');
            checkTwitterStatus();
          }
        }, 1000);

      } catch (error) {
        console.error('❌ Erreur authentification Twitter:', error.message);
        showNotification(`Erreur d'authentification Twitter: ${error.message}`, 'error');
      }
    }

    // Fonction pour vérifier le statut d'authentification Twitter
    async function checkTwitterStatus() {
    console.log('🔍 [DEBUG] Vérification statut Twitter...');

        try {
            const response = await fetch(`${BASE_URL}/api/twitter-status`, {
                headers: { 'Authorization': `Bearer ${localStorage.getItem('idToken')}` }
            });

            const status = await response.json();
            console.log('📊 [DEBUG] Statut Twitter:', status);

            if (status.authenticated && status.user) {
                console.log('✅ [DEBUG] Twitter déjà connecté:', status.user.handle);
                // Optionnel : mettre à jour l'UI pour montrer que Twitter est connecté
            } else {
                console.log('⚠️ [DEBUG] Twitter non connecté côté serveur');
            }

            return status;

        } catch (error) {
            console.error('❌ [DEBUG] Erreur vérification Twitter:', error);
            return { authenticated: false };
        }
    }

    //new

    // Fonction pour déconnecter Twitter
    async function disconnectTwitter() {
      try {
        const token = localStorage.getItem('idToken');
        if (!token) {
          throw new Error('Token Firebase manquant');
        }

        const response = await fetch(`${BASE_URL}/api/twitter-logout`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          }
        });

        const data = await response.json();

        if (data.success) {
          console.log('✅ Déconnexion Twitter réussie');
          updateTwitterUI(null);
        } else {
          throw new Error(data.error || 'Erreur lors de la déconnexion');
        }
      } catch (error) {
        console.error('❌ Erreur déconnexion Twitter:', error.message);
        showNotification(`Erreur de déconnexion: ${error.message}`, 'error');
      }
    }
    async function checkTwitterConnectionStatus() {
        console.log('🔍 [DEBUG] Vérification statut Twitter...');
        try {
            const response = await fetch(`${BASE_URL}/api/twitter-status`, {
                headers: { 'Authorization': `Bearer ${localStorage.getItem('idToken')}` }
            });
            const status = await response.json();
            console.log('📊 [DEBUG] Statut Twitter:', status);

            if (status.authenticated && status.user) {
                console.log('✅ [DEBUG] Twitter connecté:', status.user.handle);
                // Mise à jour UI (ex: bouton -> Déconnecter)
                const twitterBtn = document.createElement('button');
                twitterBtn.id = 'twitter-auth-btn';
                twitterBtn.textContent = 'Déconnexion Twitter';
                twitterBtn.onclick = disconnectTwitter;
                document.querySelector('.header').appendChild(twitterBtn);
                // Charge tweets si connecté
                loadTweets(true);
            } else {
                console.log('⚠️ [DEBUG] Twitter non connecté');
                // const twitterBtn = document.createElement('button');
                // twitterBtn.id = 'twitter-auth-btn';
                // twitterBtn.textContent = 'Connexion Twitter';
                // twitterBtn.onclick = authenticateTwitter;
                // document.querySelector('.header').appendChild(twitterBtn);
                // showNotification('Connectez Twitter pour scheduler des tweets.', 'warning');
            }
        } catch (error) {
            console.error('❌ [DEBUG] Erreur check Twitter:', error);
            showNotification('Erreur vérification Twitter.', 'error');
        }
    }

    // Appel au load
    checkTwitterConnectionStatus();
    async function fetchWithAut(url, options = {}) {
        try {
            options.headers = { ...options.headers, 'Authorization': `Bearer ${localStorage.getItem('idToken')}` };
            let response = await fetch(url, options);
            if (response.status === 401) {
                await refreshIdToken();
                options.headers['Authorization'] = `Bearer ${localStorage.getItem('idToken')}`;
                response = await fetch(url, options); // Retry once
            }
            return response;
        } catch (error) {
            throw error;
        }
    }
     function setupFilters() {
        const filterTags = document.querySelectorAll('.filter-tag');
        const clearFilter = document.getElementById('clearFilter');

        filterTags.forEach(tag => {
            tag.addEventListener('click', () => {
                if (tag.classList.contains('selected')) {
                    tag.classList.remove('selected');
                    selectedFilter = null;
                    clearFilter.classList.remove('show');
                } else {
                    filterTags.forEach(t => t.classList.remove('selected'));
                    tag.classList.add('selected');
                    selectedFilter = tag.dataset.filter;
                    clearFilter.classList.add('show');
                }
                displayTweets(tweetsDataCache);
            });
        });

        clearFilter.addEventListener('click', () => {
            filterTags.forEach(tag => tag.classList.remove('selected'));
            selectedFilter = null;
            clearFilter.classList.remove('show');
            displayTweets(tweetsDataCache);
        });
    }

    function setupCustomInput() {
        const customInputBtn = document.getElementById('customInputBtn');
        const customInput = document.getElementById('customInput');

        customInputBtn.addEventListener('click', (e) => {
            if (!customInputBtn.classList.contains('active')) {
                customInputBtn.classList.add('active');
                setTimeout(() => customInput.focus(), 300);
            }
        });

        document.addEventListener('click', (e) => {
            if (!customInputBtn.contains(e.target)) {
                customInputBtn.classList.remove('active');
            }
        });

        customInput.addEventListener('keypress', async (e) => {
            if (e.key === 'Enter' && customInput.value.trim()) {
                const message = customInput.value.trim();
                if (message.startsWith('#feedback')) {
                    await sendFeedback(message);
                } else {
                    await sendUserStyle(message);
                }
            }
        });

        updateStyleProgress();
    }
 async function loadScheduledTweets() {
        try {
            const headers = {
                'Authorization': `Bearer ${localStorage.getItem('idToken')}`,
                ...(lastETag ? { 'If-None-Match': lastETag } : {})
            };
            const response = await fetchWithRetry(`${BASE_URL}/api/tweets`, { headers, signal: AbortSignal.timeout(5000) });
            if (response.status === 401) {
                window.location.href = '/auth.html';
                return;
            }
            if (response.status === 304) {
                console.log('ℹ️ Scheduled tweets unchanged');
                return;
            }
            if (!response.ok) throw new Error(`Network error: ${response.status}`);
            const tweets = await response.json();
            lastETag = response.headers.get('ETag');
            scheduledTweets = tweets.map(tweet => ({
                ...tweet,
                datetime: new Date(tweet.datetime),
                createdAt: new Date(tweet.createdAt),
                media: tweet.media ? tweet.media.map(m => ({
                    ...m,
                    id: m.id || (m.filename + Math.random()),
                    url: m.url || `${BASE_URL}/uploads/${m.filename}`,
                    type: m.type || (m.mimetype && m.mimetype.startsWith('image/') ? 'image' : 'video'),
                    server: true,
                    mimetype: m.mimetype
                })) : []
            }));
            tweetSchedules.clear();
            selectedMedia.clear();
            scheduledTweets.forEach(tweet => {
                const scheduleKey = `${tweet.tweetId}_${tweet.tweetIndex}`;
                tweetSchedules.set(scheduleKey, tweet.datetime.toISOString());
                if (tweet.media && tweet.media.length > 0) {
                    selectedMedia.set(scheduleKey, tweet.media);
                }
            });

            scheduledTweets.forEach(tweet => {
                const tweetElement = document.getElementById(`tweet_${tweet.tweetId}_${tweet.tweetIndex}_container`);
                if (tweetElement) {
                    const timestampElement = tweetElement.querySelector('.timestamp');
                    let statusText, statusClass;
                    switch(tweet.status) {
                        case 'scheduled':
                            statusClass = 'status-scheduled';
                            statusText = tweet.datetime <= new Date() ? 'In progress...' : 'Scheduled';
                            break;
                        case 'published':
                            statusClass = 'status-published';
                            statusText = 'Published';
                            break;
                        case 'failed':
                            statusClass = 'status-failed';
                            statusText = 'Failed';
                            break;
                        default:
                            statusClass = '';
                            statusText = '';
                    }
                    timestampElement.innerHTML = `
                        ${formatDate(new Date(tweet.createdAt))}
                        ${statusText ? `<span class="status-indicator ${statusClass}"></span><span style="font-size: 10px; color: #888;">${statusText}${statusText === 'Scheduled' ? ` on ${formatDate(tweet.datetime)}` : ''}</span>` : ''}
                    `;
                    const scheduleKey = `${tweet.tweetId}_${tweet.tweetIndex}`;
                    renderMediaPreview(`tweet_${tweet.tweetId}_${tweet.tweetIndex}`, scheduleKey);
                }
            });
        } catch (error) {
            console.error('Scheduled tweets loading error:', error);
            showNotification(`Error: ${error.message}.`);
        }
    }
      async function sendFeedback(message) {
        const customInput = document.getElementById('customInput');
        if (!message) {
            showNotification('Please enter feedback.');
            return;
        }

        try {
            customInput.disabled = true;
            customInput.classList.add('loading-pulse');

            const response = await emailjs.send('service_v0fds5a', 'template_cd6fjit', {
                message,
                user_name: document.getElementById('userName').textContent,
                user_email: window.auth.currentUser?.email || 'noreply@example.com',
                to_email: 'toumoudagoujoseph@gmail.com',
                subject: 'Feedback'
            });

            if (response.status === 200) {
                customInput.value = '';
                customInput.placeholder = '✅ Feedback sent!';
                setTimeout(() => customInput.placeholder = 'Enter #feedback or your style...', 5000);
                showNotification('Feedback sent successfully!', 'success');
            } else {
                throw new Error(`Unexpected error: ${response.status}`);
            }
        } catch (error) {
            console.error('Feedback sending error:', error);
            showNotification(`Error: ${error.message}`);
        } finally {
            customInput.disabled = false;
            customInput.classList.remove('loading-pulse');
        }
    }*/
