comprends la nouvelle structure et quand c'est bon on va modifier le css
ne recode pas
si il y a des incoherences dans le designdonne moi des consignes pour reussir

lors du clic sur un tag
n'affiche plus le clear
ajoute un autre tag all qui affiche tt donc si quelqu'un veuttt voir il clique sur 'tt'




     // Add event listeners for media inputs
        document.querySelectorAll('.media-upload input').forEach(input => {
            input.addEventListener('change', (e) => {
                const tweetId = e.target.id.replace('media-input-', '');
                const [_, tweetGroupId, tweetIndex] = tweetId.split('_');
                const scheduleKey = `${tweetGroupId}_${tweetIndex}`;
                let mediaList = selectedMedia.get(scheduleKey) || [];
                if (mediaList.length >= 4) {
                    showNotification('Maximum 4 media per tweet.');
                    return;
                }
                const newFiles = Array.from(e.target.files);
                if (mediaList.length + newFiles.length > 4) {
                    showNotification(`Maximum 4 media. ${4 - mediaList.length} file(s) remaining.`);
                    return;
                }
                newFiles.forEach(file => {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const mediaItem = {
                            id: Date.now() + Math.random(),
                            file,
                            url: e.target.result,
                            type: file.type.startsWith('image/') ? 'image' : 'video',
                            mimetype: file.type
                        };
                        mediaList.push(mediaItem);
                        selectedMedia.set(scheduleKey, mediaList);
                        renderMediaPreview(tweetId, scheduleKey);
                    };
                    reader.readAsDataURL(file);
                });
                e.target.value = '';
            });
        });

        // Render media previews
        document.querySelectorAll('.media-preview').forEach(preview => {
            const tweetId = preview.id.replace('media-preview-', '');
            const scheduleKey = tweetId.replace('tweet_', '');
            renderMediaPreview(tweetId, scheduleKey);
        });
    }

    function toggleMediaUpload(tweetId) {
        const mediaContainer = document.getElementById(`media-upload-${tweetId}`);
        mediaContainer.style.display = mediaContainer.style.display === 'block' ? 'none' : 'block';
        if (mediaContainer.style.display === 'block') {
            const scheduleKey = tweetId.replace('tweet_', '');
            renderMediaPreview(tweetId, scheduleKey);
        }
    }

    function renderMediaPreview(tweetId, scheduleKey) {
        const mediaPreview = document.getElementById(`media-preview-${tweetId}`);
        if (!mediaPreview) return;

        const clientMedia = selectedMedia.get(scheduleKey) || [];
        const serverMedia = scheduledTweets.find(t => `${t.tweetId}_${t.tweetIndex}` === scheduleKey)?.media || [];
        const mergedMedia = [
            ...serverMedia.filter(m => m && m.filename && m.mimetype).map(m => ({
                id: m.id || (m.filename + Math.random()),
                url: m.url || `${BASE_URL}/uploads/${m.filename}`,
                type: m.type || (m.mimetype && m.mimetype.startsWith('image/') ? 'image' : 'video'),
                server: true,
                mimetype: m.mimetype
            })),
            ...clientMedia.filter(m => !m.server)
        ].slice(0, 4);

        mediaPreview.innerHTML = mergedMedia.map(media => `
            <div class="media-item" data-media-id="${media.id}">
                ${media.type === 'image'
                    ? `<img src="${media.url}" alt="Preview">`
                    : `<video src="${media.url}" controls style="width: 100%; height: 80px;"></video>`
                }
                ${!media.server ? `<button class="media-remove" data-schedule-key="${scheduleKey}" data-media-id="${media.id}">×</button>` : ''}
            </div>
        `).join('');

        mediaPreview.querySelectorAll('.media-remove').forEach(button => {
            button.addEventListener('click', () => {
                const scheduleKey = button.dataset.scheduleKey;
                const mediaId = parseFloat(button.dataset.mediaId);
                removeMedia(scheduleKey, mediaId, button);
            });
        });
    }

    function removeMedia(scheduleKey, mediaId, button) {
        button.disabled = true;
        button.style.background = 'rgba(0,0,0,0.05)';
        let mediaList = selectedMedia.get(scheduleKey) || [];
        const originalLength = mediaList.length;
        mediaList = mediaList.filter(media => media.id !== mediaId);
        if (mediaList.length < originalLength) {
            selectedMedia.set(scheduleKey, mediaList);
            const tweetId = `tweet_${scheduleKey}`;
            renderMediaPreview(tweetId, scheduleKey);
            showNotification('Media removed.');
        } else {
            showNotification('Error removing media.', 'error');
        }
        button.disabled = false;
        button.style.background = 'rgba(0,0,0,0.1)';
    }

    function toggleEdit(tweetId) {
        const textarea = document.getElementById(tweetId);
        const tweetPost = textarea.closest('.tweet-item').querySelector('.tweet-post');

        if (textarea.style.display === 'none' || !textarea.style.display) {
            textarea.style.display = 'block';
            tweetPost.style.display = 'none';
            textarea.focus();
            textarea.setSelectionRange(textarea.value.length, textarea.value.length);
        } else {
            textarea.style.display = 'none';
            tweetPost.style.display = 'flex';

            const [_, tweetGroupId, tweetIndex] = tweetId.split('_');
            if (textarea.dataset.dirty === 'true') {
                saveTweetEdit(tweetGroupId, parseInt(tweetIndex), textarea.value.trim());
            }
        }
    }

    async function deleteTweet(tweetId, tweetIndex) {
        if (!checkAuth()) return;
        if (!confirm('Do you really want to delete this tweet?')) return;

        const tweetElement = document.getElementById(`tweet_${tweetId}_${tweetIndex}_container`);
        const deleteBtn = tweetElement.querySelector('.delete-btn');
        const originalContent = deleteBtn.innerHTML;

        deleteBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle></svg>';
        deleteBtn.disabled = true;

        const scheduleKey = `${tweetId}_${tweetIndex}`;
        const tweetInfo = scheduledTweets.find(t => `${t.tweetId}_${t.tweetIndex}` === scheduleKey);

        const maxRetries = 3;
        let retryCount = 0;

        async function attemptDelete() {
            try {
                if (tweetInfo) {
                    const response = await fetchWithRetry(`${BASE_URL}/api/tweets/${tweetInfo.id}`, {
                        method: 'DELETE',
                        headers: {
                            'Authorization': `Bearer ${localStorage.getItem('idToken')}`
                        },
                        signal: AbortSignal.timeout(5000)
                    });
                    if (!response.ok) {
                        const result = await response.json();
                        throw new Error(result.error || `Network error: ${response.status}`);
                    }
                    scheduledTweets = scheduledTweets.filter(t => `${t.tweetId}_${t.tweetIndex}` !== scheduleKey);
                    tweetSchedules.delete(scheduleKey);
                    selectedMedia.delete(scheduleKey);
                }

                const response = await fetch(`${BASE_URL}/api/delete-tweet`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('idToken')}`
                    },
                    body: JSON.stringify({ tweetId, tweetIndex }),
                    signal: AbortSignal.timeout(5000)
                });

                if (response.status === 401) {
                    window.location.href = '/auth.html';
                    return;
                }

                const result = await response.json();
                if (!response.ok) {
                    throw new Error(result.error || `Network error: ${response.status}`);
                }

                if (result.success) {
                    tweetElement.remove();
                    const group = tweetsDataCache.find(g => g.id === tweetId);
                    if (group) {
                        group.generatedTweets.splice(tweetIndex, 1);
                        if (group.modesUsed) group.modesUsed.splice(tweetIndex, 1);
                        group.lastModified = result.data?.lastModified;
                        if (group.generatedTweets.length === 0) {
                            tweetsDataCache = tweetsDataCache.filter(g => g.id !== tweetId);
                        }
                    }
                    displayTweets(tweetsDataCache);
                    showNotification('Tweet deleted successfully!', 'success');
                    if (!document.querySelector('.tweet-item')) {
                        document.getElementById('tweets-container').innerHTML = '<div class="no-tweets">No tweets generated</div>';
                    }
                } else {
                    throw new Error(result.error || 'Unknown error');
                }
            } catch (error) {
                if (retryCount < maxRetries) {
                    retryCount++;
                    console.log(`Attempt ${retryCount}/${maxRetries} failed for deletion, retrying...`);
                    await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
                    return attemptDelete();
                }
                throw error;
            }
        }

        try {
            await attemptDelete();
        } catch (error) {
            console.error('Tweet deletion error:', error);
            showNotification(`Error: ${error.message}.`);
            deleteBtn.innerHTML = originalContent;
            deleteBtn.disabled = false;
        }
    }

    function updateCharCount(event) {
        const textarea = event.target;
        const countElement = document.getElementById(`count_${textarea.id}`);
        if (countElement) {
            const length = textarea.value.length;
            countElement.textContent = `${length}/280`;
            countElement.style.color = length > 280 ? '#dc3545' : length > 250 ? '#ffc107' : '#6c757d';
            textarea.dataset.dirty = 'true';

            // Update tweet display
            const tweetElement = textarea.closest('.tweet-item');
            const postContent = tweetElement.querySelector('.tweet-post-content');
            postContent.innerHTML = formatTweetText(textarea.value);
        }
    }

    async function saveTweetEdit(tweetId, tweetIndex, newText) {
        if (!checkAuth()) return;
        if (!newText) {
            showNotification('Tweet cannot be empty.');
            return;
        }
        if (newText.length > 280) {
            showNotification('Tweet exceeds 280 characters.');
            return;
        }

        const textarea = document.getElementById(`tweet_${tweetId}_${tweetIndex}`);
        const maxRetries = 3;
        let retryCount = 0;

        async function attemptSave() {
            try {
                textarea.disabled = true;
                textarea.classList.add('loading-pulse');

                const response = await fetch(`${BASE_URL}/api/edit-tweet`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('idToken')}`
                    },
                    body: JSON.stringify({ tweetId, tweetIndex, newText }),
                    signal: AbortSignal.timeout(5000)
                });

                if (response.status === 401) {
                    window.location.href = '/auth.html';
                    return;
                }

                const result = await response.json();
                if (!response.ok) throw new Error(result.error || `Network error: ${response.status}`);

                if (result.success) {
                    textarea.dataset.dirty = 'false';
                    updateCharCount({ target: textarea });
                    styleProgress = result.data.styleProgress || styleProgress;
                    updateStyleProgress();
                    showNotification('Tweet modified successfully!', 'success');

                    const group = tweetsDataCache.find(g => g.id === tweetId);
                    if (group) {
                        group.generatedTweets[tweetIndex] = newText;
                        group.lastModified = result.data?.lastModified;
                    }
                    const scheduleKey = `${tweetId}_${tweetIndex}`;
                    const tweetInfo = scheduledTweets.find(t => `${t.tweetId}_${t.tweetIndex}` === scheduleKey);
                    if (tweetInfo) {
                        tweetInfo.content = newText;
                    }
                    displayTweets(tweetsDataCache);
                } else {
                    throw new Error(result.error || 'Unknown error');
                }
            } catch (error) {
                if (retryCount < maxRetries) {
                    retryCount++;
                    console.log(`Attempt ${retryCount}/${maxRetries} failed for save, retrying...`);
                    await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
                    return attemptSave();
                }
                throw error;
            }
        }

        try {
            await attemptSave();
        } catch (error) {
            console.error('Tweet modification error:', error);
            showNotification(`Error: ${error.message}.`);
        } finally {
            textarea.disabled = false;
            textarea.classList.remove('loading-pulse');
        }
    }

    async function copyTweet(tweetId) {
        const textarea = document.getElementById(tweetId);
        const tweetElement = textarea.closest('.tweet-item');
        const copyBtn = tweetElement.querySelector('.copy-btn');
        const originalContent = copyBtn.innerHTML;

        try {
            await navigator.clipboard.writeText(textarea.value);
            copyBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20,6 9,17 4,12"></polyline></svg>';
            copyBtn.classList.add('copied');
            tweetElement.style.background = 'linear-gradient(145deg, #f8f9fa, #e9ecef)';
            tweetElement.style.borderColor = '#ced4da';
            showNotification('Tweet copied!', 'success');

            setTimeout(() => {
                copyBtn.innerHTML = originalContent;
                copyBtn.classList.remove('copied');
                tweetElement.style.background = 'linear-gradient(145deg, #ffffff, #f8f9fa)';
                tweetElement.style.borderColor = '#dee2e6';
            }, 2000);
        } catch (error) {
            console.error('Copy error:', error);
            showNotification('Copy error.', 'error');
            copyBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>';
            setTimeout(() => copyBtn.innerHTML = originalContent, 2000);
        }
    }

    async function regenerateTweet(tweetId, tweetIndex, mode) {
        if (!checkAuth()) return;

        const tweetElement = document.getElementById(`tweet_${tweetId}_${tweetIndex}_container`);
        const regenBtn = tweetElement.querySelector('.regen-btn');
        const originalContent = regenBtn.innerHTML;

        regenBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle></svg>';
        regenBtn.disabled = true;

        const maxRetries = 3;
        let retryCount = 0;

        async function attemptRegenerate() {
            try {
                const response = await fetch(`${BASE_URL}/api/regenerate-tweet`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('idToken')}`
                    },
                    body: JSON.stringify({ tweetId, tweetIndex, mode }),
                    signal: AbortSignal.timeout(5000)
                });

                if (response.status === 401) {
                    window.location.href = '/auth.html';
                    return;
                }

                const result = await response.json();
                if (!response.ok) throw new Error(result.error || 'Network error');

                if (result.success && result.data) {
                    const textarea = document.getElementById(`tweet_${tweetId}_${tweetIndex}`);
                    textarea.value = result.data.tweet;
                    textarea.dataset.dirty = 'false';
                    updateCharCount({ target: textarea });

                    regenBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20,6 9,17 4,12"></polyline></svg>';
                    regenBtn.classList.add('regenerated');

                    setTimeout(() => {
                        regenBtn.innerHTML = originalContent;
                        regenBtn.classList.remove('regenerated');
                        regenBtn.disabled = false;
                    }, 2000);

                    showNotification('Tweet regenerated successfully!', 'success');

                    const group = tweetsDataCache.find(g => g.id === tweetId);
                    if (group) {
                        group.generatedTweets[tweetIndex] = result.data.tweet;
                        if (group.modesUsed) group.modesUsed[tweetIndex] = mode;
                        group.lastModified = result.data?.lastModified;
                    }
                    displayTweets(tweetsDataCache);
                } else {
                    throw new Error(result.error || 'Unknown error');
                }
            } catch (error) {
                if (retryCount < maxRetries) {
                    retryCount++;
                    console.log(`Attempt ${retryCount}/${maxRetries} failed for regeneration, retrying...`);
                    await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
                    return attemptRegenerate();
                }
                throw error;
            }
        }

        try {
            await attemptRegenerate();
        } catch (error) {
            console.error('Regeneration error:', error);
            showNotification(`Error: ${error.message}.`, 'error');
            regenBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>';
            setTimeout(() => {
                regenBtn.innerHTML = originalContent;
                regenBtn.disabled = false;
            }, 2000);
        }
    }

    function openScheduleDialog(tweetId, tweetIndex) {
        currentTweetId = tweetId;
        currentTweetIndex = tweetIndex;
        const dialog = document.getElementById('schedule-dialog');
        const scheduleDate = document.getElementById('scheduleDate');
        const scheduleTime = document.getElementById('scheduleTime');
        const now = new Date();
        now.setMinutes(0, 0, 0);
        scheduleDate.min = now.toISOString().split('T')[0];
        scheduleDate.value = now.toISOString().split('T')[0];
        now.setHours(now.getHours() + 1);
        scheduleTime.value = now.toTimeString().slice(0, 5);
        dialog.style.display = 'flex';
        scheduleDate.focus();
    }

    function closeScheduleDialog() {
        document.getElementById('schedule-dialog').style.display = 'none';
        currentTweetId = null;
        currentTweetIndex = null;
    }

    async function confirmSchedule() {
        console.log('🎯 [DEBUG] confirmSchedule() appelée');

        if (!currentTweetId || currentTweetIndex === null) {
            console.log('❌ [DEBUG] Aucun tweet sélectionné:', { currentTweetId, currentTweetIndex });
            showNotification('No tweet selected.', 'error');
            return;
        }

        console.log('✅ [DEBUG] Tweet sélectionné:', { currentTweetId, currentTweetIndex });

        const scheduleDate = document.getElementById('scheduleDate');
        const scheduleTime = document.getElementById('scheduleTime');
        const content = document.getElementById(`tweet_${currentTweetId}_${currentTweetIndex}`).value.trim();
        const scheduleKey = `${currentTweetId}_${currentTweetIndex}`;
        const tweetElement = document.getElementById(`tweet_${currentTweetId}_${currentTweetIndex}_container`);
        const scheduleBtn = tweetElement.querySelector('.schedule-btn');
        const originalContent = scheduleBtn.innerHTML;

        console.log('📝 [DEBUG] Contenu du tweet:', { content, length: content.length });

        // Validations basiques
        if (!content) {
            console.log('❌ [DEBUG] Tweet vide');
            showNotification('Tweet cannot be empty.', 'error');
            return;
        }
        if (content.length > 280) {
            console.log('❌ [DEBUG] Tweet trop long:', content.length);
            showNotification('Tweet exceeds 280 characters.', 'error');
            return;
        }
        if (!scheduleDate.value || !scheduleTime.value) {
            console.log('❌ [DEBUG] Date/heure manquante:', { date: scheduleDate.value, time: scheduleTime.value });
            showNotification('Please select date and time.', 'error');
            return;
        }

        const datetime = `${scheduleDate.value}T${scheduleTime.value}:00`;
        const scheduleDateTime = new Date(datetime);
        const now = new Date();

        console.log('⏰ [DEBUG] Validation date:', {
            datetime,
            scheduleDateTime: scheduleDateTime.toISOString(),
            now: now.toISOString(),
            isFuture: scheduleDateTime > now
        });

        if (scheduleDateTime <= now) {
            console.log('❌ [DEBUG] Date dans le passé');
            showNotification('Date must be in the future.', 'error');
            return;
        }

        // UI feedback de chargement
        scheduleBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle></svg>';
        scheduleBtn.disabled = true;

        const maxRetries = 3;
        let retryCount = 0;

        async function attemptSchedule() {
            console.log(`🔄 [DEBUG] Tentative de scheduling ${retryCount + 1}/${maxRetries}`);

            try {
                const formData = new FormData();
                formData.append('content', content);
                formData.append('datetime', datetime);
                formData.append('tweetId', currentTweetId);
                formData.append('tweetIndex', currentTweetIndex);

                const mediaItems = selectedMedia.get(scheduleKey) || [];
                console.log('🖼️ [DEBUG] Médias attachés:', mediaItems.length);

                mediaItems.forEach((media, index) => {
                    if (media.file && media.mimetype) {
                        console.log(`📎 [DEBUG] Média ${index}:`, { name: media.file.name, type: media.mimetype });
                        formData.append('media', media.file, media.file.name);
                    }
                });

                console.log('📡 [DEBUG] Envoi requête vers /api/schedule-tweet...');

                const response = await fetch(`${BASE_URL}/api/schedule-tweet`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('idToken')}`
                    },
                    body: formData,
                    signal: AbortSignal.timeout(15000) // Augmenté à 15s
                });

                console.log('📥 [DEBUG] Réponse reçue:', {
                    status: response.status,
                    ok: response.ok,
                    statusText: response.statusText
                });

                if (response.status === 401) {
                    console.log('🔒 [DEBUG] Token Firebase expiré, redirection auth');
                    window.location.href = '/auth.html';
                    return;
                }

                const result = await response.json();
                console.log('📋 [DEBUG] Résultat parsing:', result);

                if (!response.ok) {
                    console.log('❌ [DEBUG] Erreur serveur:', result.error);
                    throw new Error(result.error || `Network error: ${response.status}`);
                }

                if (result.success) {
                    console.log('🎉 [DEBUG] Scheduling réussi !');

                    // Mise à jour des données locales
                    tweetSchedules.set(scheduleKey, scheduleDateTime.toISOString());
                    scheduledTweets = scheduledTweets.filter(t => `${t.tweetId}_${t.tweetIndex}` !== scheduleKey);
                    scheduledTweets.push({
                        id: result.tweet.id,
                        content,
                        datetime: scheduleDateTime,
                        media: result.tweet.media || [],
                        status: 'scheduled',
                        tweetId: currentTweetId,
                        tweetIndex: currentTweetIndex,
                        lastModified: result.tweet.lastModified,
                        createdAt: new Date(result.tweet.createdAt)
                    });

                    // Mise à jour UI
                    const timestampElement = tweetElement.querySelector('.timestamp');
                    timestampElement.innerHTML = `
                        ${formatDate(new Date(result.tweet.createdAt))}
                        <span class="status-indicator status-scheduled"></span>
                        <span style="font-size: 10px; color: #888;">Scheduled on ${formatDate(scheduleDateTime)}</span>
                    `;

                    // Reset des médias
                    selectedMedia.set(scheduleKey, []);
                    renderMediaPreview(`tweet_${currentTweetId}_${currentTweetIndex}`, scheduleKey);

                    // Feedback visuel succès
                    scheduleBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20,6 9,17 4,12"></polyline></svg>';
                    scheduleBtn.classList.add('scheduled');
                    showNotification('Tweet scheduled successfully!', 'success');

                    setTimeout(() => {
                        scheduleBtn.innerHTML = originalContent;
                        scheduleBtn.classList.remove('scheduled');
                        scheduleBtn.disabled = false;
                    }, 2000);

                    closeScheduleDialog();
                    displayTweets(tweetsDataCache);

                } else {
                    console.log('❌ [DEBUG] Échec scheduling serveur:', result.error);
                    throw new Error(result.error || 'Unknown scheduling error');
                }
            } catch (error) {
                console.error(`❌ [DEBUG] Erreur tentative ${retryCount + 1}:`, error.message);

                if (retryCount < maxRetries) {
                    retryCount++;
                    console.log(`🔄 [DEBUG] Retry ${retryCount}/${maxRetries} dans ${1000 * retryCount}ms...`);
                    await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
                    return attemptSchedule();
                }
                throw error;
            }
        }

        try {
            const status = await checkTwitterStatus(); // Appel à ta fonction checkTwitterStatus
            if (!status.authenticated) {
                showNotification('Connectez Twitter pour scheduler.', 'error');
                authenticateTwitter(); // Prompt connexion
                return;
            }
            await attemptSchedule();
        } catch (error) {
            console.error('💥 [DEBUG] Échec final scheduling:', error);
            showNotification(`Error: ${error.message}`, 'error');

            // UI feedback échec
            scheduleBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>';
            setTimeout(() => {
                scheduleBtn.innerHTML = originalContent;
                scheduleBtn.disabled = false;
            }, 2000);
        }
    }

    //new
    async function sendTwitterTokensToServer(user, credential) {
        console.log('🐦 [DEBUG] sendTwitterTokensToServer() appelée');
        console.log('👤 [DEBUG] User Firebase:', { uid: user.uid, displayName: user.displayName });
        console.log('🔑 [DEBUG] Credential reçu:', !!credential);

        try {
            const idToken = await user.getIdToken();
            console.log('🎫 [DEBUG] ID Token Firebase récupéré');

            // Extraire les tokens Twitter du credential
            let twitterAccessToken = null;
            let twitterSecret = null;

            if (credential && credential.accessToken && credential.secret) {
                // OAuth 1.0a (Twitter v1)
                twitterAccessToken = credential.accessToken;
                twitterSecret = credential.secret;
                console.log('🔐 [DEBUG] Tokens Twitter OAuth 1.0a extraits');
            } else if (credential && credential.accessToken) {
                // OAuth 2.0 (Twitter v2)
                twitterAccessToken = credential.accessToken;
                console.log('🔐 [DEBUG] Token Twitter OAuth 2.0 extrait');
            } else {
                console.log('⚠️ [DEBUG] Aucun token Twitter trouvé dans credential');
            }

            const payload = {
                twitterAccessToken,
                twitterSecret,
                userInfo: {
                    uid: user.uid,
                    displayName: user.displayName,
                    email: user.email,
                    photoURL: user.photoURL
                }
            };

            console.log('📤 [DEBUG] Envoi vers /api/login:', {
                hasTwitterToken: !!twitterAccessToken,
                hasTwitterSecret: !!twitterSecret,
                uid: user.uid
            });

            const response = await fetch(`${BASE_URL}/api/login`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${idToken}`
                },
                body: JSON.stringify(payload)
            });

            console.log('📥 [DEBUG] Réponse /api/login:', {
                status: response.status,
                ok: response.ok
            });

            const result = await response.json();
            console.log('📋 [DEBUG] Résultat /api/login:', result);

            if (result.success) {
                console.log('✅ [DEBUG] Connexion serveur réussie');
                console.log('🐦 [DEBUG] Twitter connecté:', result.twitterConnected);

                // Stocker les infos localement si nécessaire
                if (result.twitterUser) {
                    console.log('👤 [DEBUG] Info Twitter user:', result.twitterUser);
                }

                return result;
            } else {
                console.error('❌ [DEBUG] Échec connexion serveur:', result.error);
                throw new Error(result.error || 'Échec connexion serveur');
            }

        } catch (error) {
            console.error('💥 [DEBUG] Erreur sendTwitterTokensToServer:', error);
            throw error;
        }
    }
    //mew


    // Fonction pour initier l'authentification Twitter
    async function authenticateTwitter() {
      try {
        console.log('🔄 Début authentification Twitter...');

        // Récupérer le token Firebase
        const token = localStorage.getItem('idToken');
        if (!token) {
          throw new Error('Utilisateur non authentifié avec Firebase');
        }

       const response = await fetch(`${BASE_URL}/api/auth/twitter`, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      }
    });

        const data = await response.json();

        if (!response.ok) {
          throw new Error(data.error || 'Erreur lors de la demande d\'authentification');
        }

        if (!data.success || !data.authUrl) {
          throw new Error('URL d\'authentification non reçue');
        }

        console.log('✅ URL d\'authentification reçue:', data.authUrl);

        // Ajouter le token Firebase à l'URL de callback
        const authUrlWithToken = `${data.authUrl}&firebase_token=${encodeURIComponent(token)}`;

        // Ouvrir la popup d'authentification Twitter
        const popup = window.open(
          data.authUrl,
          'twitter-auth',
          'width=600,height=700,scrollbars=yes,resizable=yes'
        );

        // Écouter la fermeture de la popup
        const checkClosed = setInterval(() => {
          if (popup.closed) {
            clearInterval(checkClosed);
            console.log('🔄 Popup fermée, vérification du statut...');
            checkTwitterStatus();
          }
        }, 1000);

      } catch (error) {
        console.error('❌ Erreur authentification Twitter:', error.message);
        showNotification(`Erreur d'authentification Twitter: ${error.message}`, 'error');
      }
    }

    // Fonction pour vérifier le statut d'authentification Twitter
    async function checkTwitterStatus() {
    console.log('🔍 [DEBUG] Vérification statut Twitter...');

        try {
            const response = await fetch(`${BASE_URL}/api/twitter-status`, {
                headers: { 'Authorization': `Bearer ${localStorage.getItem('idToken')}` }
            });

            const status = await response.json();
            console.log('📊 [DEBUG] Statut Twitter:', status);

            if (status.authenticated && status.user) {
                console.log('✅ [DEBUG] Twitter déjà connecté:', status.user.handle);
                // Optionnel : mettre à jour l'UI pour montrer que Twitter est connecté
            } else {
                console.log('⚠️ [DEBUG] Twitter non connecté côté serveur');
            }

            return status;

        } catch (error) {
            console.error('❌ [DEBUG] Erreur vérification Twitter:', error);
            return { authenticated: false };
        }
    }

    //new

    // Fonction pour déconnecter Twitter
    async function disconnectTwitter() {
      try {
        const token = localStorage.getItem('idToken');
        if (!token) {
          throw new Error('Token Firebase manquant');
        }

        const response = await fetch(`${BASE_URL}/api/twitter-logout`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          }
        });

        const data = await response.json();

        if (data.success) {
          console.log('✅ Déconnexion Twitter réussie');
          updateTwitterUI(null);
        } else {
          throw new Error(data.error || 'Erreur lors de la déconnexion');
        }
      } catch (error) {
        console.error('❌ Erreur déconnexion Twitter:', error.message);
        showNotification(`Erreur de déconnexion: ${error.message}`, 'error');
      }
    }
    async function checkTwitterConnectionStatus() {
        console.log('🔍 [DEBUG] Vérification statut Twitter...');
        try {
            const response = await fetch(`${BASE_URL}/api/twitter-status`, {
                headers: { 'Authorization': `Bearer ${localStorage.getItem('idToken')}` }
            });
            const status = await response.json();
            console.log('📊 [DEBUG] Statut Twitter:', status);

            if (status.authenticated && status.user) {
                console.log('✅ [DEBUG] Twitter connecté:', status.user.handle);
                // Mise à jour UI (ex: bouton -> Déconnecter)
                const twitterBtn = document.createElement('button');
                twitterBtn.id = 'twitter-auth-btn';
                twitterBtn.textContent = 'Déconnexion Twitter';
                twitterBtn.onclick = disconnectTwitter;
                document.querySelector('.header').appendChild(twitterBtn);
                // Charge tweets si connecté
                loadTweets(true);
            } else {
                console.log('⚠️ [DEBUG] Twitter non connecté');
                // const twitterBtn = document.createElement('button');
                // twitterBtn.id = 'twitter-auth-btn';
                // twitterBtn.textContent = 'Connexion Twitter';
                // twitterBtn.onclick = authenticateTwitter;
                // document.querySelector('.header').appendChild(twitterBtn);
                // showNotification('Connectez Twitter pour scheduler des tweets.', 'warning');
            }
        } catch (error) {
            console.error('❌ [DEBUG] Erreur check Twitter:', error);
            showNotification('Erreur vérification Twitter.', 'error');
        }
    }

    // Appel au load
    checkTwitterConnectionStatus();
    async function fetchWithAut(url, options = {}) {
        try {
            options.headers = { ...options.headers, 'Authorization': `Bearer ${localStorage.getItem('idToken')}` };
            let response = await fetch(url, options);
            if (response.status === 401) {
                await refreshIdToken();
                options.headers['Authorization'] = `Bearer ${localStorage.getItem('idToken')}`;
                response = await fetch(url, options); // Retry once
            }
            return response;
        } catch (error) {
            throw error;
        }
    }
     function setupFilters() {
        const filterTags = document.querySelectorAll('.filter-tag');
        const clearFilter = document.getElementById('clearFilter');

        filterTags.forEach(tag => {
            tag.addEventListener('click', () => {
                if (tag.classList.contains('selected')) {
                    tag.classList.remove('selected');
                    selectedFilter = null;
                    clearFilter.classList.remove('show');
                } else {
                    filterTags.forEach(t => t.classList.remove('selected'));
                    tag.classList.add('selected');
                    selectedFilter = tag.dataset.filter;
                    clearFilter.classList.add('show');
                }
                displayTweets(tweetsDataCache);
            });
        });

        clearFilter.addEventListener('click', () => {
            filterTags.forEach(tag => tag.classList.remove('selected'));
            selectedFilter = null;
            clearFilter.classList.remove('show');
            displayTweets(tweetsDataCache);
        });
    }

    function setupCustomInput() {
        const customInputBtn = document.getElementById('customInputBtn');
        const customInput = document.getElementById('customInput');

        customInputBtn.addEventListener('click', (e) => {
            if (!customInputBtn.classList.contains('active')) {
                customInputBtn.classList.add('active');
                setTimeout(() => customInput.focus(), 300);
            }
        });

        document.addEventListener('click', (e) => {
            if (!customInputBtn.contains(e.target)) {
                customInputBtn.classList.remove('active');
            }
        });

        customInput.addEventListener('keypress', async (e) => {
            if (e.key === 'Enter' && customInput.value.trim()) {
                const message = customInput.value.trim();
                if (message.startsWith('#feedback')) {
                    await sendFeedback(message);
                } else {
                    await sendUserStyle(message);
                }
            }
        });

        updateStyleProgress();
    }
