comprends la nouvelle structure et quand c'est bon on va modifier le css
ne recode pas
si il y a des incoherences dans le designdonne moi des consignes pour reussir

lors du clic sur un tag
n'affiche plus le clear
ajoute un autre tag all qui affiche tt donc si quelqu'un veuttt voir il clique sur 'tt'




     // Add event listeners for media inputs
        document.querySelectorAll('.media-upload input').forEach(input => {
            input.addEventListener('change', (e) => {
                const tweetId = e.target.id.replace('media-input-', '');
                const [_, tweetGroupId, tweetIndex] = tweetId.split('_');
                const scheduleKey = `${tweetGroupId}_${tweetIndex}`;
                let mediaList = selectedMedia.get(scheduleKey) || [];
                if (mediaList.length >= 4) {
                    showNotification('Maximum 4 media per tweet.');
                    return;
                }
                const newFiles = Array.from(e.target.files);
                if (mediaList.length + newFiles.length > 4) {
                    showNotification(`Maximum 4 media. ${4 - mediaList.length} file(s) remaining.`);
                    return;
                }
                newFiles.forEach(file => {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const mediaItem = {
                            id: Date.now() + Math.random(),
                            file,
                            url: e.target.result,
                            type: file.type.startsWith('image/') ? 'image' : 'video',
                            mimetype: file.type
                        };
                        mediaList.push(mediaItem);
                        selectedMedia.set(scheduleKey, mediaList);
                        renderMediaPreview(tweetId, scheduleKey);
                    };
                    reader.readAsDataURL(file);
                });
                e.target.value = '';
            });
        });

        // Render media previews
        document.querySelectorAll('.media-preview').forEach(preview => {
            const tweetId = preview.id.replace('media-preview-', '');
            const scheduleKey = tweetId.replace('tweet_', '');
            renderMediaPreview(tweetId, scheduleKey);
        });
    }

    function toggleMediaUpload(tweetId) {
        const mediaContainer = document.getElementById(`media-upload-${tweetId}`);
        mediaContainer.style.display = mediaContainer.style.display === 'block' ? 'none' : 'block';
        if (mediaContainer.style.display === 'block') {
            const scheduleKey = tweetId.replace('tweet_', '');
            renderMediaPreview(tweetId, scheduleKey);
        }
    }

    function renderMediaPreview(tweetId, scheduleKey) {
        const mediaPreview = document.getElementById(`media-preview-${tweetId}`);
        if (!mediaPreview) return;

        const clientMedia = selectedMedia.get(scheduleKey) || [];
        const serverMedia = scheduledTweets.find(t => `${t.tweetId}_${t.tweetIndex}` === scheduleKey)?.media || [];
        const mergedMedia = [
            ...serverMedia.filter(m => m && m.filename && m.mimetype).map(m => ({
                id: m.id || (m.filename + Math.random()),
                url: m.url || `${BASE_URL}/uploads/${m.filename}`,
                type: m.type || (m.mimetype && m.mimetype.startsWith('image/') ? 'image' : 'video'),
                server: true,
                mimetype: m.mimetype
            })),
            ...clientMedia.filter(m => !m.server)
        ].slice(0, 4);

        mediaPreview.innerHTML = mergedMedia.map(media => `
            <div class="media-item" data-media-id="${media.id}">
                ${media.type === 'image'
                    ? `<img src="${media.url}" alt="Preview">`
                    : `<video src="${media.url}" controls style="width: 100%; height: 80px;"></video>`
                }
                ${!media.server ? `<button class="media-remove" data-schedule-key="${scheduleKey}" data-media-id="${media.id}">√ó</button>` : ''}
            </div>
        `).join('');

        mediaPreview.querySelectorAll('.media-remove').forEach(button => {
            button.addEventListener('click', () => {
                const scheduleKey = button.dataset.scheduleKey;
                const mediaId = parseFloat(button.dataset.mediaId);
                removeMedia(scheduleKey, mediaId, button);
            });
        });
    }

    function removeMedia(scheduleKey, mediaId, button) {
        button.disabled = true;
        button.style.background = 'rgba(0,0,0,0.05)';
        let mediaList = selectedMedia.get(scheduleKey) || [];
        const originalLength = mediaList.length;
        mediaList = mediaList.filter(media => media.id !== mediaId);
        if (mediaList.length < originalLength) {
            selectedMedia.set(scheduleKey, mediaList);
            const tweetId = `tweet_${scheduleKey}`;
            renderMediaPreview(tweetId, scheduleKey);
            showNotification('Media removed.');
        } else {
            showNotification('Error removing media.', 'error');
        }
        button.disabled = false;
        button.style.background = 'rgba(0,0,0,0.1)';
    }

    function toggleEdit(tweetId) {
        const textarea = document.getElementById(tweetId);
        const tweetPost = textarea.closest('.tweet-item').querySelector('.tweet-post');

        if (textarea.style.display === 'none' || !textarea.style.display) {
            textarea.style.display = 'block';
            tweetPost.style.display = 'none';
            textarea.focus();
            textarea.setSelectionRange(textarea.value.length, textarea.value.length);
        } else {
            textarea.style.display = 'none';
            tweetPost.style.display = 'flex';

            const [_, tweetGroupId, tweetIndex] = tweetId.split('_');
            if (textarea.dataset.dirty === 'true') {
                saveTweetEdit(tweetGroupId, parseInt(tweetIndex), textarea.value.trim());
            }
        }
    }

    async function deleteTweet(tweetId, tweetIndex) {
        if (!checkAuth()) return;
        if (!confirm('Do you really want to delete this tweet?')) return;

        const tweetElement = document.getElementById(`tweet_${tweetId}_${tweetIndex}_container`);
        const deleteBtn = tweetElement.querySelector('.delete-btn');
        const originalContent = deleteBtn.innerHTML;

        deleteBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle></svg>';
        deleteBtn.disabled = true;

        const scheduleKey = `${tweetId}_${tweetIndex}`;
        const tweetInfo = scheduledTweets.find(t => `${t.tweetId}_${t.tweetIndex}` === scheduleKey);

        const maxRetries = 3;
        let retryCount = 0;

        async function attemptDelete() {
            try {
                if (tweetInfo) {
                    const response = await fetchWithRetry(`${BASE_URL}/api/tweets/${tweetInfo.id}`, {
                        method: 'DELETE',
                        headers: {
                            'Authorization': `Bearer ${localStorage.getItem('idToken')}`
                        },
                        signal: AbortSignal.timeout(5000)
                    });
                    if (!response.ok) {
                        const result = await response.json();
                        throw new Error(result.error || `Network error: ${response.status}`);
                    }
                    scheduledTweets = scheduledTweets.filter(t => `${t.tweetId}_${t.tweetIndex}` !== scheduleKey);
                    tweetSchedules.delete(scheduleKey);
                    selectedMedia.delete(scheduleKey);
                }

                const response = await fetch(`${BASE_URL}/api/delete-tweet`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('idToken')}`
                    },
                    body: JSON.stringify({ tweetId, tweetIndex }),
                    signal: AbortSignal.timeout(5000)
                });

                if (response.status === 401) {
                    window.location.href = '/auth.html';
                    return;
                }

                const result = await response.json();
                if (!response.ok) {
                    throw new Error(result.error || `Network error: ${response.status}`);
                }

                if (result.success) {
                    tweetElement.remove();
                    const group = tweetsDataCache.find(g => g.id === tweetId);
                    if (group) {
                        group.generatedTweets.splice(tweetIndex, 1);
                        if (group.modesUsed) group.modesUsed.splice(tweetIndex, 1);
                        group.lastModified = result.data?.lastModified;
                        if (group.generatedTweets.length === 0) {
                            tweetsDataCache = tweetsDataCache.filter(g => g.id !== tweetId);
                        }
                    }
                    displayTweets(tweetsDataCache);
                    showNotification('Tweet deleted successfully!', 'success');
                    if (!document.querySelector('.tweet-item')) {
                        document.getElementById('tweets-container').innerHTML = '<div class="no-tweets">No tweets generated</div>';
                    }
                } else {
                    throw new Error(result.error || 'Unknown error');
                }
            } catch (error) {
                if (retryCount < maxRetries) {
                    retryCount++;
                    console.log(`Attempt ${retryCount}/${maxRetries} failed for deletion, retrying...`);
                    await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
                    return attemptDelete();
                }
                throw error;
            }
        }

        try {
            await attemptDelete();
        } catch (error) {
            console.error('Tweet deletion error:', error);
            showNotification(`Error: ${error.message}.`);
            deleteBtn.innerHTML = originalContent;
            deleteBtn.disabled = false;
        }
    }

    function updateCharCount(event) {
        const textarea = event.target;
        const countElement = document.getElementById(`count_${textarea.id}`);
        if (countElement) {
            const length = textarea.value.length;
            countElement.textContent = `${length}/280`;
            countElement.style.color = length > 280 ? '#dc3545' : length > 250 ? '#ffc107' : '#6c757d';
            textarea.dataset.dirty = 'true';

            // Update tweet display
            const tweetElement = textarea.closest('.tweet-item');
            const postContent = tweetElement.querySelector('.tweet-post-content');
            postContent.innerHTML = formatTweetText(textarea.value);
        }
    }

    async function saveTweetEdit(tweetId, tweetIndex, newText) {
        if (!checkAuth()) return;
        if (!newText) {
            showNotification('Tweet cannot be empty.');
            return;
        }
        if (newText.length > 280) {
            showNotification('Tweet exceeds 280 characters.');
            return;
        }

        const textarea = document.getElementById(`tweet_${tweetId}_${tweetIndex}`);
        const maxRetries = 3;
        let retryCount = 0;

        async function attemptSave() {
            try {
                textarea.disabled = true;
                textarea.classList.add('loading-pulse');

                const response = await fetch(`${BASE_URL}/api/edit-tweet`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('idToken')}`
                    },
                    body: JSON.stringify({ tweetId, tweetIndex, newText }),
                    signal: AbortSignal.timeout(5000)
                });

                if (response.status === 401) {
                    window.location.href = '/auth.html';
                    return;
                }

                const result = await response.json();
                if (!response.ok) throw new Error(result.error || `Network error: ${response.status}`);

                if (result.success) {
                    textarea.dataset.dirty = 'false';
                    updateCharCount({ target: textarea });
                    styleProgress = result.data.styleProgress || styleProgress;
                    updateStyleProgress();
                    showNotification('Tweet modified successfully!', 'success');

                    const group = tweetsDataCache.find(g => g.id === tweetId);
                    if (group) {
                        group.generatedTweets[tweetIndex] = newText;
                        group.lastModified = result.data?.lastModified;
                    }
                    const scheduleKey = `${tweetId}_${tweetIndex}`;
                    const tweetInfo = scheduledTweets.find(t => `${t.tweetId}_${t.tweetIndex}` === scheduleKey);
                    if (tweetInfo) {
                        tweetInfo.content = newText;
                    }
                    displayTweets(tweetsDataCache);
                } else {
                    throw new Error(result.error || 'Unknown error');
                }
            } catch (error) {
                if (retryCount < maxRetries) {
                    retryCount++;
                    console.log(`Attempt ${retryCount}/${maxRetries} failed for save, retrying...`);
                    await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
                    return attemptSave();
                }
                throw error;
            }
        }

        try {
            await attemptSave();
        } catch (error) {
            console.error('Tweet modification error:', error);
            showNotification(`Error: ${error.message}.`);
        } finally {
            textarea.disabled = false;
            textarea.classList.remove('loading-pulse');
        }
    }

    async function copyTweet(tweetId) {
        const textarea = document.getElementById(tweetId);
        const tweetElement = textarea.closest('.tweet-item');
        const copyBtn = tweetElement.querySelector('.copy-btn');
        const originalContent = copyBtn.innerHTML;

        try {
            await navigator.clipboard.writeText(textarea.value);
            copyBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20,6 9,17 4,12"></polyline></svg>';
            copyBtn.classList.add('copied');
            tweetElement.style.background = 'linear-gradient(145deg, #f8f9fa, #e9ecef)';
            tweetElement.style.borderColor = '#ced4da';
            showNotification('Tweet copied!', 'success');

            setTimeout(() => {
                copyBtn.innerHTML = originalContent;
                copyBtn.classList.remove('copied');
                tweetElement.style.background = 'linear-gradient(145deg, #ffffff, #f8f9fa)';
                tweetElement.style.borderColor = '#dee2e6';
            }, 2000);
        } catch (error) {
            console.error('Copy error:', error);
            showNotification('Copy error.', 'error');
            copyBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>';
            setTimeout(() => copyBtn.innerHTML = originalContent, 2000);
        }
    }

    async function regenerateTweet(tweetId, tweetIndex, mode) {
        if (!checkAuth()) return;

        const tweetElement = document.getElementById(`tweet_${tweetId}_${tweetIndex}_container`);
        const regenBtn = tweetElement.querySelector('.regen-btn');
        const originalContent = regenBtn.innerHTML;

        regenBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle></svg>';
        regenBtn.disabled = true;

        const maxRetries = 3;
        let retryCount = 0;

        async function attemptRegenerate() {
            try {
                const response = await fetch(`${BASE_URL}/api/regenerate-tweet`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('idToken')}`
                    },
                    body: JSON.stringify({ tweetId, tweetIndex, mode }),
                    signal: AbortSignal.timeout(5000)
                });

                if (response.status === 401) {
                    window.location.href = '/auth.html';
                    return;
                }

                const result = await response.json();
                if (!response.ok) throw new Error(result.error || 'Network error');

                if (result.success && result.data) {
                    const textarea = document.getElementById(`tweet_${tweetId}_${tweetIndex}`);
                    textarea.value = result.data.tweet;
                    textarea.dataset.dirty = 'false';
                    updateCharCount({ target: textarea });

                    regenBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20,6 9,17 4,12"></polyline></svg>';
                    regenBtn.classList.add('regenerated');

                    setTimeout(() => {
                        regenBtn.innerHTML = originalContent;
                        regenBtn.classList.remove('regenerated');
                        regenBtn.disabled = false;
                    }, 2000);

                    showNotification('Tweet regenerated successfully!', 'success');

                    const group = tweetsDataCache.find(g => g.id === tweetId);
                    if (group) {
                        group.generatedTweets[tweetIndex] = result.data.tweet;
                        if (group.modesUsed) group.modesUsed[tweetIndex] = mode;
                        group.lastModified = result.data?.lastModified;
                    }
                    displayTweets(tweetsDataCache);
                } else {
                    throw new Error(result.error || 'Unknown error');
                }
            } catch (error) {
                if (retryCount < maxRetries) {
                    retryCount++;
                    console.log(`Attempt ${retryCount}/${maxRetries} failed for regeneration, retrying...`);
                    await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
                    return attemptRegenerate();
                }
                throw error;
            }
        }

        try {
            await attemptRegenerate();
        } catch (error) {
            console.error('Regeneration error:', error);
            showNotification(`Error: ${error.message}.`, 'error');
            regenBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>';
            setTimeout(() => {
                regenBtn.innerHTML = originalContent;
                regenBtn.disabled = false;
            }, 2000);
        }
    }

    function openScheduleDialog(tweetId, tweetIndex) {
        currentTweetId = tweetId;
        currentTweetIndex = tweetIndex;
        const dialog = document.getElementById('schedule-dialog');
        const scheduleDate = document.getElementById('scheduleDate');
        const scheduleTime = document.getElementById('scheduleTime');
        const now = new Date();
        now.setMinutes(0, 0, 0);
        scheduleDate.min = now.toISOString().split('T')[0];
        scheduleDate.value = now.toISOString().split('T')[0];
        now.setHours(now.getHours() + 1);
        scheduleTime.value = now.toTimeString().slice(0, 5);
        dialog.style.display = 'flex';
        scheduleDate.focus();
    }

    function closeScheduleDialog() {
        document.getElementById('schedule-dialog').style.display = 'none';
        currentTweetId = null;
        currentTweetIndex = null;
    }

    async function confirmSchedule() {
        console.log('üéØ [DEBUG] confirmSchedule() appel√©e');

        if (!currentTweetId || currentTweetIndex === null) {
            console.log('‚ùå [DEBUG] Aucun tweet s√©lectionn√©:', { currentTweetId, currentTweetIndex });
            showNotification('No tweet selected.', 'error');
            return;
        }

        console.log('‚úÖ [DEBUG] Tweet s√©lectionn√©:', { currentTweetId, currentTweetIndex });

        const scheduleDate = document.getElementById('scheduleDate');
        const scheduleTime = document.getElementById('scheduleTime');
        const content = document.getElementById(`tweet_${currentTweetId}_${currentTweetIndex}`).value.trim();
        const scheduleKey = `${currentTweetId}_${currentTweetIndex}`;
        const tweetElement = document.getElementById(`tweet_${currentTweetId}_${currentTweetIndex}_container`);
        const scheduleBtn = tweetElement.querySelector('.schedule-btn');
        const originalContent = scheduleBtn.innerHTML;

        console.log('üìù [DEBUG] Contenu du tweet:', { content, length: content.length });

        // Validations basiques
        if (!content) {
            console.log('‚ùå [DEBUG] Tweet vide');
            showNotification('Tweet cannot be empty.', 'error');
            return;
        }
        if (content.length > 280) {
            console.log('‚ùå [DEBUG] Tweet trop long:', content.length);
            showNotification('Tweet exceeds 280 characters.', 'error');
            return;
        }
        if (!scheduleDate.value || !scheduleTime.value) {
            console.log('‚ùå [DEBUG] Date/heure manquante:', { date: scheduleDate.value, time: scheduleTime.value });
            showNotification('Please select date and time.', 'error');
            return;
        }

        const datetime = `${scheduleDate.value}T${scheduleTime.value}:00`;
        const scheduleDateTime = new Date(datetime);
        const now = new Date();

        console.log('‚è∞ [DEBUG] Validation date:', {
            datetime,
            scheduleDateTime: scheduleDateTime.toISOString(),
            now: now.toISOString(),
            isFuture: scheduleDateTime > now
        });

        if (scheduleDateTime <= now) {
            console.log('‚ùå [DEBUG] Date dans le pass√©');
            showNotification('Date must be in the future.', 'error');
            return;
        }

        // UI feedback de chargement
        scheduleBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle></svg>';
        scheduleBtn.disabled = true;

        const maxRetries = 3;
        let retryCount = 0;

        async function attemptSchedule() {
            console.log(`üîÑ [DEBUG] Tentative de scheduling ${retryCount + 1}/${maxRetries}`);

            try {
                const formData = new FormData();
                formData.append('content', content);
                formData.append('datetime', datetime);
                formData.append('tweetId', currentTweetId);
                formData.append('tweetIndex', currentTweetIndex);

                const mediaItems = selectedMedia.get(scheduleKey) || [];
                console.log('üñºÔ∏è [DEBUG] M√©dias attach√©s:', mediaItems.length);

                mediaItems.forEach((media, index) => {
                    if (media.file && media.mimetype) {
                        console.log(`üìé [DEBUG] M√©dia ${index}:`, { name: media.file.name, type: media.mimetype });
                        formData.append('media', media.file, media.file.name);
                    }
                });

                console.log('üì° [DEBUG] Envoi requ√™te vers /api/schedule-tweet...');

                const response = await fetch(`${BASE_URL}/api/schedule-tweet`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('idToken')}`
                    },
                    body: formData,
                    signal: AbortSignal.timeout(15000) // Augment√© √† 15s
                });

                console.log('üì• [DEBUG] R√©ponse re√ßue:', {
                    status: response.status,
                    ok: response.ok,
                    statusText: response.statusText
                });

                if (response.status === 401) {
                    console.log('üîí [DEBUG] Token Firebase expir√©, redirection auth');
                    window.location.href = '/auth.html';
                    return;
                }

                const result = await response.json();
                console.log('üìã [DEBUG] R√©sultat parsing:', result);

                if (!response.ok) {
                    console.log('‚ùå [DEBUG] Erreur serveur:', result.error);
                    throw new Error(result.error || `Network error: ${response.status}`);
                }

                if (result.success) {
                    console.log('üéâ [DEBUG] Scheduling r√©ussi !');

                    // Mise √† jour des donn√©es locales
                    tweetSchedules.set(scheduleKey, scheduleDateTime.toISOString());
                    scheduledTweets = scheduledTweets.filter(t => `${t.tweetId}_${t.tweetIndex}` !== scheduleKey);
                    scheduledTweets.push({
                        id: result.tweet.id,
                        content,
                        datetime: scheduleDateTime,
                        media: result.tweet.media || [],
                        status: 'scheduled',
                        tweetId: currentTweetId,
                        tweetIndex: currentTweetIndex,
                        lastModified: result.tweet.lastModified,
                        createdAt: new Date(result.tweet.createdAt)
                    });

                    // Mise √† jour UI
                    const timestampElement = tweetElement.querySelector('.timestamp');
                    timestampElement.innerHTML = `
                        ${formatDate(new Date(result.tweet.createdAt))}
                        <span class="status-indicator status-scheduled"></span>
                        <span style="font-size: 10px; color: #888;">Scheduled on ${formatDate(scheduleDateTime)}</span>
                    `;

                    // Reset des m√©dias
                    selectedMedia.set(scheduleKey, []);
                    renderMediaPreview(`tweet_${currentTweetId}_${currentTweetIndex}`, scheduleKey);

                    // Feedback visuel succ√®s
                    scheduleBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20,6 9,17 4,12"></polyline></svg>';
                    scheduleBtn.classList.add('scheduled');
                    showNotification('Tweet scheduled successfully!', 'success');

                    setTimeout(() => {
                        scheduleBtn.innerHTML = originalContent;
                        scheduleBtn.classList.remove('scheduled');
                        scheduleBtn.disabled = false;
                    }, 2000);

                    closeScheduleDialog();
                    displayTweets(tweetsDataCache);

                } else {
                    console.log('‚ùå [DEBUG] √âchec scheduling serveur:', result.error);
                    throw new Error(result.error || 'Unknown scheduling error');
                }
            } catch (error) {
                console.error(`‚ùå [DEBUG] Erreur tentative ${retryCount + 1}:`, error.message);

                if (retryCount < maxRetries) {
                    retryCount++;
                    console.log(`üîÑ [DEBUG] Retry ${retryCount}/${maxRetries} dans ${1000 * retryCount}ms...`);
                    await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
                    return attemptSchedule();
                }
                throw error;
            }
        }

        try {
            const status = await checkTwitterStatus(); // Appel √† ta fonction checkTwitterStatus
            if (!status.authenticated) {
                showNotification('Connectez Twitter pour scheduler.', 'error');
                authenticateTwitter(); // Prompt connexion
                return;
            }
            await attemptSchedule();
        } catch (error) {
            console.error('üí• [DEBUG] √âchec final scheduling:', error);
            showNotification(`Error: ${error.message}`, 'error');

            // UI feedback √©chec
            scheduleBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>';
            setTimeout(() => {
                scheduleBtn.innerHTML = originalContent;
                scheduleBtn.disabled = false;
            }, 2000);
        }
    }

    //new
    async function sendTwitterTokensToServer(user, credential) {
        console.log('üê¶ [DEBUG] sendTwitterTokensToServer() appel√©e');
        console.log('üë§ [DEBUG] User Firebase:', { uid: user.uid, displayName: user.displayName });
        console.log('üîë [DEBUG] Credential re√ßu:', !!credential);

        try {
            const idToken = await user.getIdToken();
            console.log('üé´ [DEBUG] ID Token Firebase r√©cup√©r√©');

            // Extraire les tokens Twitter du credential
            let twitterAccessToken = null;
            let twitterSecret = null;

            if (credential && credential.accessToken && credential.secret) {
                // OAuth 1.0a (Twitter v1)
                twitterAccessToken = credential.accessToken;
                twitterSecret = credential.secret;
                console.log('üîê [DEBUG] Tokens Twitter OAuth 1.0a extraits');
            } else if (credential && credential.accessToken) {
                // OAuth 2.0 (Twitter v2)
                twitterAccessToken = credential.accessToken;
                console.log('üîê [DEBUG] Token Twitter OAuth 2.0 extrait');
            } else {
                console.log('‚ö†Ô∏è [DEBUG] Aucun token Twitter trouv√© dans credential');
            }

            const payload = {
                twitterAccessToken,
                twitterSecret,
                userInfo: {
                    uid: user.uid,
                    displayName: user.displayName,
                    email: user.email,
                    photoURL: user.photoURL
                }
            };

            console.log('üì§ [DEBUG] Envoi vers /api/login:', {
                hasTwitterToken: !!twitterAccessToken,
                hasTwitterSecret: !!twitterSecret,
                uid: user.uid
            });

            const response = await fetch(`${BASE_URL}/api/login`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${idToken}`
                },
                body: JSON.stringify(payload)
            });

            console.log('üì• [DEBUG] R√©ponse /api/login:', {
                status: response.status,
                ok: response.ok
            });

            const result = await response.json();
            console.log('üìã [DEBUG] R√©sultat /api/login:', result);

            if (result.success) {
                console.log('‚úÖ [DEBUG] Connexion serveur r√©ussie');
                console.log('üê¶ [DEBUG] Twitter connect√©:', result.twitterConnected);

                // Stocker les infos localement si n√©cessaire
                if (result.twitterUser) {
                    console.log('üë§ [DEBUG] Info Twitter user:', result.twitterUser);
                }

                return result;
            } else {
                console.error('‚ùå [DEBUG] √âchec connexion serveur:', result.error);
                throw new Error(result.error || '√âchec connexion serveur');
            }

        } catch (error) {
            console.error('üí• [DEBUG] Erreur sendTwitterTokensToServer:', error);
            throw error;
        }
    }
    //mew


    // Fonction pour initier l'authentification Twitter
    async function authenticateTwitter() {
      try {
        console.log('üîÑ D√©but authentification Twitter...');

        // R√©cup√©rer le token Firebase
        const token = localStorage.getItem('idToken');
        if (!token) {
          throw new Error('Utilisateur non authentifi√© avec Firebase');
        }

       const response = await fetch(`${BASE_URL}/api/auth/twitter`, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      }
    });

        const data = await response.json();

        if (!response.ok) {
          throw new Error(data.error || 'Erreur lors de la demande d\'authentification');
        }

        if (!data.success || !data.authUrl) {
          throw new Error('URL d\'authentification non re√ßue');
        }

        console.log('‚úÖ URL d\'authentification re√ßue:', data.authUrl);

        // Ajouter le token Firebase √† l'URL de callback
        const authUrlWithToken = `${data.authUrl}&firebase_token=${encodeURIComponent(token)}`;

        // Ouvrir la popup d'authentification Twitter
        const popup = window.open(
          data.authUrl,
          'twitter-auth',
          'width=600,height=700,scrollbars=yes,resizable=yes'
        );

        // √âcouter la fermeture de la popup
        const checkClosed = setInterval(() => {
          if (popup.closed) {
            clearInterval(checkClosed);
            console.log('üîÑ Popup ferm√©e, v√©rification du statut...');
            checkTwitterStatus();
          }
        }, 1000);

      } catch (error) {
        console.error('‚ùå Erreur authentification Twitter:', error.message);
        showNotification(`Erreur d'authentification Twitter: ${error.message}`, 'error');
      }
    }

    // Fonction pour v√©rifier le statut d'authentification Twitter
    async function checkTwitterStatus() {
    console.log('üîç [DEBUG] V√©rification statut Twitter...');

        try {
            const response = await fetch(`${BASE_URL}/api/twitter-status`, {
                headers: { 'Authorization': `Bearer ${localStorage.getItem('idToken')}` }
            });

            const status = await response.json();
            console.log('üìä [DEBUG] Statut Twitter:', status);

            if (status.authenticated && status.user) {
                console.log('‚úÖ [DEBUG] Twitter d√©j√† connect√©:', status.user.handle);
                // Optionnel : mettre √† jour l'UI pour montrer que Twitter est connect√©
            } else {
                console.log('‚ö†Ô∏è [DEBUG] Twitter non connect√© c√¥t√© serveur');
            }

            return status;

        } catch (error) {
            console.error('‚ùå [DEBUG] Erreur v√©rification Twitter:', error);
            return { authenticated: false };
        }
    }

    //new

    // Fonction pour d√©connecter Twitter
    async function disconnectTwitter() {
      try {
        const token = localStorage.getItem('idToken');
        if (!token) {
          throw new Error('Token Firebase manquant');
        }

        const response = await fetch(`${BASE_URL}/api/twitter-logout`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          }
        });

        const data = await response.json();

        if (data.success) {
          console.log('‚úÖ D√©connexion Twitter r√©ussie');
          updateTwitterUI(null);
        } else {
          throw new Error(data.error || 'Erreur lors de la d√©connexion');
        }
      } catch (error) {
        console.error('‚ùå Erreur d√©connexion Twitter:', error.message);
        showNotification(`Erreur de d√©connexion: ${error.message}`, 'error');
      }
    }
    async function checkTwitterConnectionStatus() {
        console.log('üîç [DEBUG] V√©rification statut Twitter...');
        try {
            const response = await fetch(`${BASE_URL}/api/twitter-status`, {
                headers: { 'Authorization': `Bearer ${localStorage.getItem('idToken')}` }
            });
            const status = await response.json();
            console.log('üìä [DEBUG] Statut Twitter:', status);

            if (status.authenticated && status.user) {
                console.log('‚úÖ [DEBUG] Twitter connect√©:', status.user.handle);
                // Mise √† jour UI (ex: bouton -> D√©connecter)
                const twitterBtn = document.createElement('button');
                twitterBtn.id = 'twitter-auth-btn';
                twitterBtn.textContent = 'D√©connexion Twitter';
                twitterBtn.onclick = disconnectTwitter;
                document.querySelector('.header').appendChild(twitterBtn);
                // Charge tweets si connect√©
                loadTweets(true);
            } else {
                console.log('‚ö†Ô∏è [DEBUG] Twitter non connect√©');
                // const twitterBtn = document.createElement('button');
                // twitterBtn.id = 'twitter-auth-btn';
                // twitterBtn.textContent = 'Connexion Twitter';
                // twitterBtn.onclick = authenticateTwitter;
                // document.querySelector('.header').appendChild(twitterBtn);
                // showNotification('Connectez Twitter pour scheduler des tweets.', 'warning');
            }
        } catch (error) {
            console.error('‚ùå [DEBUG] Erreur check Twitter:', error);
            showNotification('Erreur v√©rification Twitter.', 'error');
        }
    }

    // Appel au load
    checkTwitterConnectionStatus();
    async function fetchWithAut(url, options = {}) {
        try {
            options.headers = { ...options.headers, 'Authorization': `Bearer ${localStorage.getItem('idToken')}` };
            let response = await fetch(url, options);
            if (response.status === 401) {
                await refreshIdToken();
                options.headers['Authorization'] = `Bearer ${localStorage.getItem('idToken')}`;
                response = await fetch(url, options); // Retry once
            }
            return response;
        } catch (error) {
            throw error;
        }
    }
     function setupFilters() {
        const filterTags = document.querySelectorAll('.filter-tag');
        const clearFilter = document.getElementById('clearFilter');

        filterTags.forEach(tag => {
            tag.addEventListener('click', () => {
                if (tag.classList.contains('selected')) {
                    tag.classList.remove('selected');
                    selectedFilter = null;
                    clearFilter.classList.remove('show');
                } else {
                    filterTags.forEach(t => t.classList.remove('selected'));
                    tag.classList.add('selected');
                    selectedFilter = tag.dataset.filter;
                    clearFilter.classList.add('show');
                }
                displayTweets(tweetsDataCache);
            });
        });

        clearFilter.addEventListener('click', () => {
            filterTags.forEach(tag => tag.classList.remove('selected'));
            selectedFilter = null;
            clearFilter.classList.remove('show');
            displayTweets(tweetsDataCache);
        });
    }

    function setupCustomInput() {
        const customInputBtn = document.getElementById('customInputBtn');
        const customInput = document.getElementById('customInput');

        customInputBtn.addEventListener('click', (e) => {
            if (!customInputBtn.classList.contains('active')) {
                customInputBtn.classList.add('active');
                setTimeout(() => customInput.focus(), 300);
            }
        });

        document.addEventListener('click', (e) => {
            if (!customInputBtn.contains(e.target)) {
                customInputBtn.classList.remove('active');
            }
        });

        customInput.addEventListener('keypress', async (e) => {
            if (e.key === 'Enter' && customInput.value.trim()) {
                const message = customInput.value.trim();
                if (message.startsWith('#feedback')) {
                    await sendFeedback(message);
                } else {
                    await sendUserStyle(message);
                }
            }
        });

        updateStyleProgress();
    }
